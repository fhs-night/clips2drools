# Generated from E:/pycharm/repository/lex\clipsparser.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00a4")
        buf.write("\u0566\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\3\2\3\2\7\2\u00ff\n\2\f\2")
        buf.write("\16\2\u0102\13\2\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5")
        buf.write("\4\u010d\n\4\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\5\6\u011a\n\6\3\7\3\7\5\7\u011e\n\7\3\b\3\b\3\b\3\b")
        buf.write("\3\b\5\b\u0125\n\b\3\t\3\t\7\t\u0129\n\t\f\t\16\t\u012c")
        buf.write("\13\t\3\t\3\t\3\n\3\n\3\13\3\13\3\13\3\13\3\13\5\13\u0137")
        buf.write("\n\13\3\f\3\f\5\f\u013b\n\f\3\r\3\r\3\16\3\16\3\17\3\17")
        buf.write("\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u014b\n")
        buf.write("\21\3\22\3\22\3\22\7\22\u0150\n\22\f\22\16\22\u0153\13")
        buf.write("\22\3\22\3\22\3\23\3\23\3\23\7\23\u015a\n\23\f\23\16\23")
        buf.write("\u015d\13\23\3\23\3\23\3\24\3\24\3\24\7\24\u0164\n\24")
        buf.write("\f\24\16\24\u0167\13\24\3\24\3\24\3\25\3\25\3\25\6\25")
        buf.write("\u016e\n\25\r\25\16\25\u016f\3\25\3\25\3\26\3\26\3\26")
        buf.write("\3\26\3\26\3\26\3\26\5\26\u017b\n\26\3\27\3\27\3\27\3")
        buf.write("\27\7\27\u0181\n\27\f\27\16\27\u0184\13\27\3\27\3\27\7")
        buf.write("\27\u0188\n\27\f\27\16\27\u018b\13\27\3\27\3\27\7\27\u018f")
        buf.write("\n\27\f\27\16\27\u0192\13\27\5\27\u0194\n\27\3\27\3\27")
        buf.write("\3\30\3\30\3\30\3\30\5\30\u019c\n\30\3\30\7\30\u019f\n")
        buf.write("\30\f\30\16\30\u01a2\13\30\3\30\3\30\3\31\3\31\3\31\3")
        buf.write("\31\7\31\u01aa\n\31\f\31\16\31\u01ad\13\31\3\31\5\31\u01b0")
        buf.write("\n\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\7\32\u01b9\n")
        buf.write("\32\f\32\16\32\u01bc\13\32\3\32\3\32\3\33\3\33\3\33\3")
        buf.write("\33\5\33\u01c4\n\33\3\33\7\33\u01c7\n\33\f\33\16\33\u01ca")
        buf.write("\13\33\3\33\3\33\3\34\3\34\3\34\5\34\u01d1\n\34\3\34\3")
        buf.write("\34\3\35\3\35\3\35\3\35\3\36\3\36\3\36\3\36\3\36\7\36")
        buf.write("\u01de\n\36\f\36\16\36\u01e1\13\36\3\36\3\36\3\37\3\37")
        buf.write("\3\37\7\37\u01e8\n\37\f\37\16\37\u01eb\13\37\3\37\3\37")
        buf.write("\3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \5 \u01fb\n \3!\3")
        buf.write("!\3!\3!\5!\u0201\n!\3!\7!\u0204\n!\f!\16!\u0207\13!\3")
        buf.write("!\3!\3\"\3\"\3\"\6\"\u020e\n\"\r\"\16\"\u020f\3\"\3\"")
        buf.write("\3#\3#\3#\3#\3#\3$\3$\5$\u021b\n$\3%\3%\3%\3%\3%\3&\3")
        buf.write("&\3&\7&\u0225\n&\f&\16&\u0228\13&\3&\3&\3\'\3\'\3\'\5")
        buf.write("\'\u022f\n\'\3(\3(\5(\u0233\n(\3)\3)\3)\3)\5)\u0239\n")
        buf.write(")\3)\7)\u023c\n)\f)\16)\u023f\13)\3)\3)\3*\3*\5*\u0245")
        buf.write("\n*\3+\3+\3+\3+\7+\u024b\n+\f+\16+\u024e\13+\3+\3+\3,")
        buf.write("\3,\3,\3,\7,\u0256\n,\f,\16,\u0259\13,\3,\3,\3-\3-\5-")
        buf.write("\u025f\n-\3.\3.\3.\3.\3.\7.\u0266\n.\f.\16.\u0269\13.")
        buf.write("\5.\u026b\n.\3.\3.\3.\3.\7.\u0271\n.\f.\16.\u0274\13.")
        buf.write("\3.\5.\u0277\n.\3/\3/\3/\3/\5/\u027d\n/\3\60\3\60\3\60")
        buf.write("\6\60\u0282\n\60\r\60\16\60\u0283\3\60\5\60\u0287\n\60")
        buf.write("\3\60\3\60\3\61\3\61\3\61\6\61\u028e\n\61\r\61\16\61\u028f")
        buf.write("\3\61\5\61\u0293\n\61\3\61\3\61\3\61\3\61\6\61\u0299\n")
        buf.write("\61\r\61\16\61\u029a\3\61\5\61\u029e\n\61\3\61\3\61\3")
        buf.write("\61\3\61\6\61\u02a4\n\61\r\61\16\61\u02a5\3\61\5\61\u02a9")
        buf.write("\n\61\3\61\3\61\3\61\3\61\6\61\u02af\n\61\r\61\16\61\u02b0")
        buf.write("\3\61\5\61\u02b4\n\61\3\61\3\61\3\61\3\61\6\61\u02ba\n")
        buf.write("\61\r\61\16\61\u02bb\3\61\5\61\u02bf\n\61\3\61\3\61\3")
        buf.write("\61\3\61\6\61\u02c5\n\61\r\61\16\61\u02c6\3\61\5\61\u02ca")
        buf.write("\n\61\3\61\3\61\3\61\3\61\6\61\u02d0\n\61\r\61\16\61\u02d1")
        buf.write("\3\61\5\61\u02d5\n\61\3\61\3\61\3\61\3\61\3\61\5\61\u02dc")
        buf.write("\n\61\3\61\3\61\3\61\3\61\6\61\u02e2\n\61\r\61\16\61\u02e3")
        buf.write("\3\61\5\61\u02e7\n\61\3\61\5\61\u02ea\n\61\3\62\3\62\3")
        buf.write("\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\3\63\3\64")
        buf.write("\3\64\3\65\3\65\3\66\3\66\5\66\u02fe\n\66\3\67\3\67\5")
        buf.write("\67\u0302\n\67\38\38\38\58\u0307\n8\38\78\u030a\n8\f8")
        buf.write("\168\u030d\138\38\38\39\39\39\39\3:\3:\3:\3:\5:\u0319")
        buf.write("\n:\3:\5:\u031c\n:\3:\7:\u031f\n:\f:\16:\u0322\13:\3:")
        buf.write("\3:\7:\u0326\n:\f:\16:\u0329\13:\3:\3:\3;\3;\3<\3<\3<")
        buf.write("\6<\u0332\n<\r<\16<\u0333\3<\3<\3=\3=\3=\3=\3=\3=\3=\3")
        buf.write("=\3=\3=\5=\u0342\n=\3>\3>\3>\3>\3>\3>\3>\3>\3>\5>\u034d")
        buf.write("\n>\3?\3?\3?\5?\u0352\n?\3@\3@\3@\3@\3A\3A\3A\3A\3A\3")
        buf.write("B\3B\3B\6B\u0360\nB\rB\16B\u0361\3B\3B\3C\3C\3C\6C\u0369")
        buf.write("\nC\rC\16C\u036a\3C\3C\3D\3D\3D\6D\u0372\nD\rD\16D\u0373")
        buf.write("\3D\3D\3E\3E\3E\3E\3E\3F\3F\3F\6F\u0380\nF\rF\16F\u0381")
        buf.write("\3F\3F\3G\3G\3G\3G\6G\u038a\nG\rG\16G\u038b\3G\3G\3H\3")
        buf.write("H\3H\7H\u0393\nH\fH\16H\u0396\13H\3H\3H\3I\3I\3I\5I\u039d")
        buf.write("\nI\3J\3J\3J\3J\3J\3J\3J\3J\3J\5J\u03a8\nJ\3K\3K\3K\5")
        buf.write("K\u03ad\nK\3L\3L\3L\3L\3L\3L\3L\5L\u03b6\nL\3M\3M\3M\3")
        buf.write("M\3M\3N\3N\3N\7N\u03c0\nN\fN\16N\u03c3\13N\3N\3N\3O\3")
        buf.write("O\5O\u03c9\nO\3P\3P\3P\7P\u03ce\nP\fP\16P\u03d1\13P\3")
        buf.write("P\3P\3Q\3Q\3Q\3Q\3Q\3Q\3Q\3Q\7Q\u03dd\nQ\fQ\16Q\u03e0")
        buf.write("\13Q\3Q\3Q\5Q\u03e4\nQ\3R\3R\3R\7R\u03e9\nR\fR\16R\u03ec")
        buf.write("\13R\3R\3R\3S\3S\3S\3S\5S\u03f4\nS\3S\7S\u03f7\nS\fS\16")
        buf.write("S\u03fa\13S\3S\3S\3T\3T\3T\3T\3T\3T\3T\3T\3T\3T\3T\5T")
        buf.write("\u0409\nT\3U\3U\3U\3U\3U\3U\3U\3U\3U\3U\6U\u0415\nU\r")
        buf.write("U\16U\u0416\5U\u0419\nU\3V\3V\3W\3W\3W\3W\5W\u0421\nW")
        buf.write("\3W\3W\7W\u0425\nW\fW\16W\u0428\13W\3W\3W\3X\3X\7X\u042e")
        buf.write("\nX\fX\16X\u0431\13X\3X\5X\u0434\nX\3X\3X\3Y\3Y\3Z\3Z")
        buf.write("\3[\3[\3[\3[\5[\u0440\n[\3[\3[\3[\6[\u0445\n[\r[\16[\u0446")
        buf.write("\3[\3[\5[\u044b\n[\3[\5[\u044e\n[\3[\7[\u0451\n[\f[\16")
        buf.write("[\u0454\13[\3[\7[\u0457\n[\f[\16[\u045a\13[\3[\3[\3\\")
        buf.write("\3\\\3\\\3\\\3\\\3]\3]\3]\3]\3]\3^\3^\3^\3^\7^\u046c\n")
        buf.write("^\f^\16^\u046f\13^\3^\3^\3^\3^\3^\3^\7^\u0477\n^\f^\16")
        buf.write("^\u047a\13^\3^\3^\3^\3^\3^\3^\7^\u0482\n^\f^\16^\u0485")
        buf.write("\13^\3^\3^\5^\u0489\n^\3_\3_\3_\3_\3_\3_\3_\3_\3_\3_\3")
        buf.write("_\5_\u0496\n_\3`\3`\3`\3`\3`\7`\u049d\n`\f`\16`\u04a0")
        buf.write("\13`\5`\u04a2\n`\3`\3`\3`\3`\7`\u04a8\n`\f`\16`\u04ab")
        buf.write("\13`\3`\5`\u04ae\n`\3a\3a\3a\3a\3a\3b\3b\3b\3b\3b\3c\3")
        buf.write("c\3c\3c\3c\3d\3d\3d\3d\3d\3e\3e\3e\3e\3e\3f\3f\3f\3f\3")
        buf.write("f\3g\3g\3g\3g\3g\3h\3h\3h\3h\5h\u04d7\nh\3h\3h\3i\3i\3")
        buf.write("i\3i\5i\u04df\ni\3i\3i\3j\3j\3k\3k\3k\3k\5k\u04e9\nk\3")
        buf.write("k\3k\3l\3l\3l\3l\5l\u04f1\nl\3l\5l\u04f4\nl\3l\7l\u04f7")
        buf.write("\nl\fl\16l\u04fa\13l\3l\3l\3m\3m\3m\3m\3n\5n\u0503\nn")
        buf.write("\3n\3n\3n\7n\u0508\nn\fn\16n\u050b\13n\3o\3o\3o\7o\u0510")
        buf.write("\no\fo\16o\u0513\13o\3o\3o\3p\3p\3p\3p\5p\u051b\np\3q")
        buf.write("\3q\3q\3q\3q\3q\3r\3r\3r\3r\3r\3r\3s\3s\3s\3s\3s\7s\u052e")
        buf.write("\ns\fs\16s\u0531\13s\3s\3s\3t\3t\3t\5t\u0538\nt\3u\3u")
        buf.write("\6u\u053c\nu\ru\16u\u053d\3u\3u\3v\3v\3v\6v\u0545\nv\r")
        buf.write("v\16v\u0546\3v\3v\3w\3w\3w\3w\3w\3x\3x\3y\3y\3z\3z\3z")
        buf.write("\5z\u0557\nz\3{\3{\3|\3|\3}\3}\3}\3}\3}\5}\u0562\n}\3")
        buf.write("~\3~\3~\2\2\177\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprt")
        buf.write("vxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e")
        buf.write("\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0")
        buf.write("\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2")
        buf.write("\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4")
        buf.write("\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6")
        buf.write("\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8")
        buf.write("\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6\u00f8\u00fa")
        buf.write("\2\25\3\2\u00a0\u00a2\6\2\37 \u0082\u0082\u0084\u0087")
        buf.write("\u0096\u0096\5\2\36\36!!##\6\2\3\4$$\u0088\u008b\u0091")
        buf.write("\u0092\3\2\13\25\5\2\63\64\66\6689\3\2UV\3\2XY\3\2\\]")
        buf.write("\3\2_a\3\2cd\3\2fg\3\2ij\5\2KK__lm\3\2ps\3\2vw\3\2xz\3")
        buf.write("\2{|\3\2/\61\2\u05b9\2\u0100\3\2\2\2\4\u0103\3\2\2\2\6")
        buf.write("\u010c\3\2\2\2\b\u010e\3\2\2\2\n\u0119\3\2\2\2\f\u011d")
        buf.write("\3\2\2\2\16\u0124\3\2\2\2\20\u0126\3\2\2\2\22\u012f\3")
        buf.write("\2\2\2\24\u0136\3\2\2\2\26\u013a\3\2\2\2\30\u013c\3\2")
        buf.write("\2\2\32\u013e\3\2\2\2\34\u0140\3\2\2\2\36\u0142\3\2\2")
        buf.write("\2 \u014a\3\2\2\2\"\u014c\3\2\2\2$\u0156\3\2\2\2&\u0160")
        buf.write("\3\2\2\2(\u016a\3\2\2\2*\u017a\3\2\2\2,\u017c\3\2\2\2")
        buf.write(".\u0197\3\2\2\2\60\u01a5\3\2\2\2\62\u01b3\3\2\2\2\64\u01bf")
        buf.write("\3\2\2\2\66\u01cd\3\2\2\28\u01d4\3\2\2\2:\u01d8\3\2\2")
        buf.write("\2<\u01e4\3\2\2\2>\u01fa\3\2\2\2@\u01fc\3\2\2\2B\u020a")
        buf.write("\3\2\2\2D\u0213\3\2\2\2F\u021a\3\2\2\2H\u021c\3\2\2\2")
        buf.write("J\u0221\3\2\2\2L\u022e\3\2\2\2N\u0232\3\2\2\2P\u0234\3")
        buf.write("\2\2\2R\u0244\3\2\2\2T\u0246\3\2\2\2V\u0251\3\2\2\2X\u025e")
        buf.write("\3\2\2\2Z\u0276\3\2\2\2\\\u027c\3\2\2\2^\u027e\3\2\2\2")
        buf.write("`\u02e9\3\2\2\2b\u02eb\3\2\2\2d\u02f1\3\2\2\2f\u02f7\3")
        buf.write("\2\2\2h\u02f9\3\2\2\2j\u02fd\3\2\2\2l\u0301\3\2\2\2n\u0303")
        buf.write("\3\2\2\2p\u0310\3\2\2\2r\u0314\3\2\2\2t\u032c\3\2\2\2")
        buf.write("v\u032e\3\2\2\2x\u0341\3\2\2\2z\u034c\3\2\2\2|\u0351\3")
        buf.write("\2\2\2~\u0353\3\2\2\2\u0080\u0357\3\2\2\2\u0082\u035c")
        buf.write("\3\2\2\2\u0084\u0365\3\2\2\2\u0086\u036e\3\2\2\2\u0088")
        buf.write("\u0377\3\2\2\2\u008a\u037c\3\2\2\2\u008c\u0385\3\2\2\2")
        buf.write("\u008e\u038f\3\2\2\2\u0090\u039c\3\2\2\2\u0092\u03a7\3")
        buf.write("\2\2\2\u0094\u03ac\3\2\2\2\u0096\u03b5\3\2\2\2\u0098\u03b7")
        buf.write("\3\2\2\2\u009a\u03bc\3\2\2\2\u009c\u03c8\3\2\2\2\u009e")
        buf.write("\u03ca\3\2\2\2\u00a0\u03e3\3\2\2\2\u00a2\u03e5\3\2\2\2")
        buf.write("\u00a4\u03ef\3\2\2\2\u00a6\u0408\3\2\2\2\u00a8\u0418\3")
        buf.write("\2\2\2\u00aa\u041a\3\2\2\2\u00ac\u041c\3\2\2\2\u00ae\u042b")
        buf.write("\3\2\2\2\u00b0\u0437\3\2\2\2\u00b2\u0439\3\2\2\2\u00b4")
        buf.write("\u043b\3\2\2\2\u00b6\u045d\3\2\2\2\u00b8\u0462\3\2\2\2")
        buf.write("\u00ba\u0488\3\2\2\2\u00bc\u0495\3\2\2\2\u00be\u04ad\3")
        buf.write("\2\2\2\u00c0\u04af\3\2\2\2\u00c2\u04b4\3\2\2\2\u00c4\u04b9")
        buf.write("\3\2\2\2\u00c6\u04be\3\2\2\2\u00c8\u04c3\3\2\2\2\u00ca")
        buf.write("\u04c8\3\2\2\2\u00cc\u04cd\3\2\2\2\u00ce\u04d2\3\2\2\2")
        buf.write("\u00d0\u04da\3\2\2\2\u00d2\u04e2\3\2\2\2\u00d4\u04e4\3")
        buf.write("\2\2\2\u00d6\u04ec\3\2\2\2\u00d8\u04fd\3\2\2\2\u00da\u0502")
        buf.write("\3\2\2\2\u00dc\u050c\3\2\2\2\u00de\u051a\3\2\2\2\u00e0")
        buf.write("\u051c\3\2\2\2\u00e2\u0522\3\2\2\2\u00e4\u0528\3\2\2\2")
        buf.write("\u00e6\u0537\3\2\2\2\u00e8\u0539\3\2\2\2\u00ea\u0541\3")
        buf.write("\2\2\2\u00ec\u054a\3\2\2\2\u00ee\u054f\3\2\2\2\u00f0\u0551")
        buf.write("\3\2\2\2\u00f2\u0556\3\2\2\2\u00f4\u0558\3\2\2\2\u00f6")
        buf.write("\u055a\3\2\2\2\u00f8\u0561\3\2\2\2\u00fa\u0563\3\2\2\2")
        buf.write("\u00fc\u00ff\5\6\4\2\u00fd\u00ff\5\n\6\2\u00fe\u00fc\3")
        buf.write("\2\2\2\u00fe\u00fd\3\2\2\2\u00ff\u0102\3\2\2\2\u0100\u00fe")
        buf.write("\3\2\2\2\u0100\u0101\3\2\2\2\u0101\3\3\2\2\2\u0102\u0100")
        buf.write("\3\2\2\2\u0103\u0104\t\2\2\2\u0104\5\3\2\2\2\u0105\u010d")
        buf.write("\5\u00f8}\2\u0106\u010d\5\4\3\2\u0107\u010d\5 \21\2\u0108")
        buf.write("\u010d\5z>\2\u0109\u010d\5\34\17\2\u010a\u010d\5\30\r")
        buf.write("\2\u010b\u010d\7\u00a4\2\2\u010c\u0105\3\2\2\2\u010c\u0106")
        buf.write("\3\2\2\2\u010c\u0107\3\2\2\2\u010c\u0108\3\2\2\2\u010c")
        buf.write("\u0109\3\2\2\2\u010c\u010a\3\2\2\2\u010c\u010b\3\2\2\2")
        buf.write("\u010d\7\3\2\2\2\u010e\u010f\5\6\4\2\u010f\t\3\2\2\2\u0110")
        buf.write("\u011a\5r:\2\u0111\u011a\5@!\2\u0112\u011a\5n8\2\u0113")
        buf.write("\u011a\5P)\2\u0114\u011a\5\u00acW\2\u0115\u011a\5\u00a4")
        buf.write("S\2\u0116\u011a\5\u00b4[\2\u0117\u011a\5\u00d4k\2\u0118")
        buf.write("\u011a\5\u00d6l\2\u0119\u0110\3\2\2\2\u0119\u0111\3\2")
        buf.write("\2\2\u0119\u0112\3\2\2\2\u0119\u0113\3\2\2\2\u0119\u0114")
        buf.write("\3\2\2\2\u0119\u0115\3\2\2\2\u0119\u0116\3\2\2\2\u0119")
        buf.write("\u0117\3\2\2\2\u0119\u0118\3\2\2\2\u011a\13\3\2\2\2\u011b")
        buf.write("\u011e\5\u00eex\2\u011c\u011e\5\u00f0y\2\u011d\u011b\3")
        buf.write("\2\2\2\u011d\u011c\3\2\2\2\u011e\r\3\2\2\2\u011f\u0125")
        buf.write("\5\u00f8}\2\u0120\u0125\5\36\20\2\u0121\u0125\5\30\r\2")
        buf.write("\u0122\u0125\5\34\17\2\u0123\u0125\5\32\16\2\u0124\u011f")
        buf.write("\3\2\2\2\u0124\u0120\3\2\2\2\u0124\u0121\3\2\2\2\u0124")
        buf.write("\u0122\3\2\2\2\u0124\u0123\3\2\2\2\u0125\17\3\2\2\2\u0126")
        buf.write("\u012a\7~\2\2\u0127\u0129\5\16\b\2\u0128\u0127\3\2\2\2")
        buf.write("\u0129\u012c\3\2\2\2\u012a\u0128\3\2\2\2\u012a\u012b\3")
        buf.write("\2\2\2\u012b\u012d\3\2\2\2\u012c\u012a\3\2\2\2\u012d\u012e")
        buf.write("\7\177\2\2\u012e\21\3\2\2\2\u012f\u0130\5\4\3\2\u0130")
        buf.write("\23\3\2\2\2\u0131\u0137\7\u00a0\2\2\u0132\u0137\5\u00f8")
        buf.write("}\2\u0133\u0137\5\30\r\2\u0134\u0137\5\34\17\2\u0135\u0137")
        buf.write("\5\32\16\2\u0136\u0131\3\2\2\2\u0136\u0132\3\2\2\2\u0136")
        buf.write("\u0133\3\2\2\2\u0136\u0134\3\2\2\2\u0136\u0135\3\2\2\2")
        buf.write("\u0137\25\3\2\2\2\u0138\u013b\5\u00f4{\2\u0139\u013b\5")
        buf.write("\u00f2z\2\u013a\u0138\3\2\2\2\u013a\u0139\3\2\2\2\u013b")
        buf.write("\27\3\2\2\2\u013c\u013d\t\3\2\2\u013d\31\3\2\2\2\u013e")
        buf.write("\u013f\t\4\2\2\u013f\33\3\2\2\2\u0140\u0141\t\5\2\2\u0141")
        buf.write("\35\3\2\2\2\u0142\u0143\5\u00f2z\2\u0143\37\3\2\2\2\u0144")
        buf.write("\u014b\5\"\22\2\u0145\u014b\5*\26\2\u0146\u014b\5\u00de")
        buf.write("p\2\u0147\u014b\5$\23\2\u0148\u014b\5(\25\2\u0149\u014b")
        buf.write("\5&\24\2\u014a\u0144\3\2\2\2\u014a\u0145\3\2\2\2\u014a")
        buf.write("\u0146\3\2\2\2\u014a\u0147\3\2\2\2\u014a\u0148\3\2\2\2")
        buf.write("\u014a\u0149\3\2\2\2\u014b!\3\2\2\2\u014c\u014d\7~\2\2")
        buf.write("\u014d\u0151\5\36\20\2\u014e\u0150\5\6\4\2\u014f\u014e")
        buf.write("\3\2\2\2\u0150\u0153\3\2\2\2\u0151\u014f\3\2\2\2\u0151")
        buf.write("\u0152\3\2\2\2\u0152\u0154\3\2\2\2\u0153\u0151\3\2\2\2")
        buf.write("\u0154\u0155\7\177\2\2\u0155#\3\2\2\2\u0156\u0157\7~\2")
        buf.write("\2\u0157\u015b\5\34\17\2\u0158\u015a\5\6\4\2\u0159\u0158")
        buf.write("\3\2\2\2\u015a\u015d\3\2\2\2\u015b\u0159\3\2\2\2\u015b")
        buf.write("\u015c\3\2\2\2\u015c\u015e\3\2\2\2\u015d\u015b\3\2\2\2")
        buf.write("\u015e\u015f\7\177\2\2\u015f%\3\2\2\2\u0160\u0161\7~\2")
        buf.write("\2\u0161\u0165\5\30\r\2\u0162\u0164\5\6\4\2\u0163\u0162")
        buf.write("\3\2\2\2\u0164\u0167\3\2\2\2\u0165\u0163\3\2\2\2\u0165")
        buf.write("\u0166\3\2\2\2\u0166\u0168\3\2\2\2\u0167\u0165\3\2\2\2")
        buf.write("\u0168\u0169\7\177\2\2\u0169\'\3\2\2\2\u016a\u016b\7~")
        buf.write("\2\2\u016b\u016d\5\32\16\2\u016c\u016e\5\6\4\2\u016d\u016c")
        buf.write("\3\2\2\2\u016e\u016f\3\2\2\2\u016f\u016d\3\2\2\2\u016f")
        buf.write("\u0170\3\2\2\2\u0170\u0171\3\2\2\2\u0171\u0172\7\177\2")
        buf.write("\2\u0172)\3\2\2\2\u0173\u017b\5,\27\2\u0174\u017b\5.\30")
        buf.write("\2\u0175\u017b\5\60\31\2\u0176\u017b\5\62\32\2\u0177\u017b")
        buf.write("\5\64\33\2\u0178\u017b\5\66\34\2\u0179\u017b\58\35\2\u017a")
        buf.write("\u0173\3\2\2\2\u017a\u0174\3\2\2\2\u017a\u0175\3\2\2\2")
        buf.write("\u017a\u0176\3\2\2\2\u017a\u0177\3\2\2\2\u017a\u0178\3")
        buf.write("\2\2\2\u017a\u0179\3\2\2\2\u017b+\3\2\2\2\u017c\u017d")
        buf.write("\7~\2\2\u017d\u017e\7\30\2\2\u017e\u0182\5\6\4\2\u017f")
        buf.write("\u0181\7\u00a4\2\2\u0180\u017f\3\2\2\2\u0181\u0184\3\2")
        buf.write("\2\2\u0182\u0180\3\2\2\2\u0182\u0183\3\2\2\2\u0183\u0185")
        buf.write("\3\2\2\2\u0184\u0182\3\2\2\2\u0185\u0189\7\31\2\2\u0186")
        buf.write("\u0188\5\b\5\2\u0187\u0186\3\2\2\2\u0188\u018b\3\2\2\2")
        buf.write("\u0189\u0187\3\2\2\2\u0189\u018a\3\2\2\2\u018a\u0193\3")
        buf.write("\2\2\2\u018b\u0189\3\2\2\2\u018c\u0190\7\32\2\2\u018d")
        buf.write("\u018f\5\b\5\2\u018e\u018d\3\2\2\2\u018f\u0192\3\2\2\2")
        buf.write("\u0190\u018e\3\2\2\2\u0190\u0191\3\2\2\2\u0191\u0194\3")
        buf.write("\2\2\2\u0192\u0190\3\2\2\2\u0193\u018c\3\2\2\2\u0193\u0194")
        buf.write("\3\2\2\2\u0194\u0195\3\2\2\2\u0195\u0196\7\177\2\2\u0196")
        buf.write("-\3\2\2\2\u0197\u0198\7~\2\2\u0198\u0199\7\26\2\2\u0199")
        buf.write("\u019b\5\6\4\2\u019a\u019c\7\27\2\2\u019b\u019a\3\2\2")
        buf.write("\2\u019b\u019c\3\2\2\2\u019c\u01a0\3\2\2\2\u019d\u019f")
        buf.write("\5\b\5\2\u019e\u019d\3\2\2\2\u019f\u01a2\3\2\2\2\u01a0")
        buf.write("\u019e\3\2\2\2\u01a0\u01a1\3\2\2\2\u01a1\u01a3\3\2\2\2")
        buf.write("\u01a2\u01a0\3\2\2\2\u01a3\u01a4\7\177\2\2\u01a4/\3\2")
        buf.write("\2\2\u01a5\u01a6\7~\2\2\u01a6\u01a7\7\34\2\2\u01a7\u01ab")
        buf.write("\5\22\n\2\u01a8\u01aa\5:\36\2\u01a9\u01a8\3\2\2\2\u01aa")
        buf.write("\u01ad\3\2\2\2\u01ab\u01a9\3\2\2\2\u01ab\u01ac\3\2\2\2")
        buf.write("\u01ac\u01af\3\2\2\2\u01ad\u01ab\3\2\2\2\u01ae\u01b0\5")
        buf.write("<\37\2\u01af\u01ae\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b1")
        buf.write("\3\2\2\2\u01b1\u01b2\7\177\2\2\u01b2\61\3\2\2\2\u01b3")
        buf.write("\u01b4\7~\2\2\u01b4\u01b5\7\35\2\2\u01b5\u01b6\5\4\3\2")
        buf.write("\u01b6\u01ba\5\20\t\2\u01b7\u01b9\5\6\4\2\u01b8\u01b7")
        buf.write("\3\2\2\2\u01b9\u01bc\3\2\2\2\u01ba\u01b8\3\2\2\2\u01ba")
        buf.write("\u01bb\3\2\2\2\u01bb\u01bd\3\2\2\2\u01bc\u01ba\3\2\2\2")
        buf.write("\u01bd\u01be\7\177\2\2\u01be\63\3\2\2\2\u01bf\u01c0\7")
        buf.write("~\2\2\u01c0\u01c1\7.\2\2\u01c1\u01c3\5> \2\u01c2\u01c4")
        buf.write("\7\27\2\2\u01c3\u01c2\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4")
        buf.write("\u01c8\3\2\2\2\u01c5\u01c7\5\b\5\2\u01c6\u01c5\3\2\2\2")
        buf.write("\u01c7\u01ca\3\2\2\2\u01c8\u01c6\3\2\2\2\u01c8\u01c9\3")
        buf.write("\2\2\2\u01c9\u01cb\3\2\2\2\u01ca\u01c8\3\2\2\2\u01cb\u01cc")
        buf.write("\7\177\2\2\u01cc\65\3\2\2\2\u01cd\u01ce\7~\2\2\u01ce\u01d0")
        buf.write("\7\33\2\2\u01cf\u01d1\5\6\4\2\u01d0\u01cf\3\2\2\2\u01d0")
        buf.write("\u01d1\3\2\2\2\u01d1\u01d2\3\2\2\2\u01d2\u01d3\7\177\2")
        buf.write("\2\u01d3\67\3\2\2\2\u01d4\u01d5\7~\2\2\u01d5\u01d6\7*")
        buf.write("\2\2\u01d6\u01d7\7\177\2\2\u01d79\3\2\2\2\u01d8\u01d9")
        buf.write("\7~\2\2\u01d9\u01da\7+\2\2\u01da\u01db\5\24\13\2\u01db")
        buf.write("\u01df\7\31\2\2\u01dc\u01de\5\b\5\2\u01dd\u01dc\3\2\2")
        buf.write("\2\u01de\u01e1\3\2\2\2\u01df\u01dd\3\2\2\2\u01df\u01e0")
        buf.write("\3\2\2\2\u01e0\u01e2\3\2\2\2\u01e1\u01df\3\2\2\2\u01e2")
        buf.write("\u01e3\7\177\2\2\u01e3;\3\2\2\2\u01e4\u01e5\7~\2\2\u01e5")
        buf.write("\u01e9\7,\2\2\u01e6\u01e8\5\b\5\2\u01e7\u01e6\3\2\2\2")
        buf.write("\u01e8\u01eb\3\2\2\2\u01e9\u01e7\3\2\2\2\u01e9\u01ea\3")
        buf.write("\2\2\2\u01ea\u01ec\3\2\2\2\u01eb\u01e9\3\2\2\2\u01ec\u01ed")
        buf.write("\7\177\2\2\u01ed=\3\2\2\2\u01ee\u01fb\5\u00eex\2\u01ef")
        buf.write("\u01f0\7~\2\2\u01f0\u01f1\5\4\3\2\u01f1\u01f2\5\u00ee")
        buf.write("x\2\u01f2\u01f3\5\u00eex\2\u01f3\u01f4\7\177\2\2\u01f4")
        buf.write("\u01fb\3\2\2\2\u01f5\u01f6\7~\2\2\u01f6\u01f7\5\4\3\2")
        buf.write("\u01f7\u01f8\5\u00eex\2\u01f8\u01f9\7\177\2\2\u01f9\u01fb")
        buf.write("\3\2\2\2\u01fa\u01ee\3\2\2\2\u01fa\u01ef\3\2\2\2\u01fa")
        buf.write("\u01f5\3\2\2\2\u01fb?\3\2\2\2\u01fc\u01fd\7~\2\2\u01fd")
        buf.write("\u01fe\7\62\2\2\u01fe\u0200\5\u00f2z\2\u01ff\u0201\5\u00f4")
        buf.write("{\2\u0200\u01ff\3\2\2\2\u0200\u0201\3\2\2\2\u0201\u0205")
        buf.write("\3\2\2\2\u0202\u0204\5N(\2\u0203\u0202\3\2\2\2\u0204\u0207")
        buf.write("\3\2\2\2\u0205\u0203\3\2\2\2\u0205\u0206\3\2\2\2\u0206")
        buf.write("\u0208\3\2\2\2\u0207\u0205\3\2\2\2\u0208\u0209\7\177\2")
        buf.write("\2\u0209A\3\2\2\2\u020a\u020b\7~\2\2\u020b\u020d\5\u00f2")
        buf.write("z\2\u020c\u020e\5L\'\2\u020d\u020c\3\2\2\2\u020e\u020f")
        buf.write("\3\2\2\2\u020f\u020d\3\2\2\2\u020f\u0210\3\2\2\2\u0210")
        buf.write("\u0211\3\2\2\2\u0211\u0212\7\177\2\2\u0212C\3\2\2\2\u0213")
        buf.write("\u0214\7~\2\2\u0214\u0215\5\u00f2z\2\u0215\u0216\5F$\2")
        buf.write("\u0216\u0217\7\177\2\2\u0217E\3\2\2\2\u0218\u021b\5H%")
        buf.write("\2\u0219\u021b\5J&\2\u021a\u0218\3\2\2\2\u021a\u0219\3")
        buf.write("\2\2\2\u021bG\3\2\2\2\u021c\u021d\7~\2\2\u021d\u021e\5")
        buf.write("\u00f2z\2\u021e\u021f\5L\'\2\u021f\u0220\7\177\2\2\u0220")
        buf.write("I\3\2\2\2\u0221\u0222\7~\2\2\u0222\u0226\5\u00f2z\2\u0223")
        buf.write("\u0225\5L\'\2\u0224\u0223\3\2\2\2\u0225\u0228\3\2\2\2")
        buf.write("\u0226\u0224\3\2\2\2\u0226\u0227\3\2\2\2\u0227\u0229\3")
        buf.write("\2\2\2\u0228\u0226\3\2\2\2\u0229\u022a\7\177\2\2\u022a")
        buf.write("K\3\2\2\2\u022b\u022f\5\4\3\2\u022c\u022f\5\u00f8}\2\u022d")
        buf.write("\u022f\5 \21\2\u022e\u022b\3\2\2\2\u022e\u022c\3\2\2\2")
        buf.write("\u022e\u022d\3\2\2\2\u022fM\3\2\2\2\u0230\u0233\5B\"\2")
        buf.write("\u0231\u0233\5D#\2\u0232\u0230\3\2\2\2\u0232\u0231\3\2")
        buf.write("\2\2\u0233O\3\2\2\2\u0234\u0235\7~\2\2\u0235\u0236\7\63")
        buf.write("\2\2\u0236\u0238\5\u00f2z\2\u0237\u0239\5\u00f4{\2\u0238")
        buf.write("\u0237\3\2\2\2\u0238\u0239\3\2\2\2\u0239\u023d\3\2\2\2")
        buf.write("\u023a\u023c\5R*\2\u023b\u023a\3\2\2\2\u023c\u023f\3\2")
        buf.write("\2\2\u023d\u023b\3\2\2\2\u023d\u023e\3\2\2\2\u023e\u0240")
        buf.write("\3\2\2\2\u023f\u023d\3\2\2\2\u0240\u0241\7\177\2\2\u0241")
        buf.write("Q\3\2\2\2\u0242\u0245\5T+\2\u0243\u0245\5V,\2\u0244\u0242")
        buf.write("\3\2\2\2\u0244\u0243\3\2\2\2\u0245S\3\2\2\2\u0246\u0247")
        buf.write("\7~\2\2\u0247\u0248\7;\2\2\u0248\u024c\5\u00f2z\2\u0249")
        buf.write("\u024b\5X-\2\u024a\u0249\3\2\2\2\u024b\u024e\3\2\2\2\u024c")
        buf.write("\u024a\3\2\2\2\u024c\u024d\3\2\2\2\u024d\u024f\3\2\2\2")
        buf.write("\u024e\u024c\3\2\2\2\u024f\u0250\7\177\2\2\u0250U\3\2")
        buf.write("\2\2\u0251\u0252\7~\2\2\u0252\u0253\7<\2\2\u0253\u0257")
        buf.write("\5\u00f2z\2\u0254\u0256\5X-\2\u0255\u0254\3\2\2\2\u0256")
        buf.write("\u0259\3\2\2\2\u0257\u0255\3\2\2\2\u0257\u0258\3\2\2\2")
        buf.write("\u0258\u025a\3\2\2\2\u0259\u0257\3\2\2\2\u025a\u025b\7")
        buf.write("\177\2\2\u025bW\3\2\2\2\u025c\u025f\5Z.\2\u025d\u025f")
        buf.write("\5\\/\2\u025e\u025c\3\2\2\2\u025e\u025d\3\2\2\2\u025f")
        buf.write("Y\3\2\2\2\u0260\u0261\7~\2\2\u0261\u026a\7,\2\2\u0262")
        buf.write("\u026b\7J\2\2\u0263\u026b\7K\2\2\u0264\u0266\5\6\4\2\u0265")
        buf.write("\u0264\3\2\2\2\u0266\u0269\3\2\2\2\u0267\u0265\3\2\2\2")
        buf.write("\u0267\u0268\3\2\2\2\u0268\u026b\3\2\2\2\u0269\u0267\3")
        buf.write("\2\2\2\u026a\u0262\3\2\2\2\u026a\u0263\3\2\2\2\u026a\u0267")
        buf.write("\3\2\2\2\u026b\u026c\3\2\2\2\u026c\u0277\7\177\2\2\u026d")
        buf.write("\u026e\7~\2\2\u026e\u0272\7L\2\2\u026f\u0271\5\6\4\2\u0270")
        buf.write("\u026f\3\2\2\2\u0271\u0274\3\2\2\2\u0272\u0270\3\2\2\2")
        buf.write("\u0272\u0273\3\2\2\2\u0273\u0275\3\2\2\2\u0274\u0272\3")
        buf.write("\2\2\2\u0275\u0277\7\177\2\2\u0276\u0260\3\2\2\2\u0276")
        buf.write("\u026d\3\2\2\2\u0277[\3\2\2\2\u0278\u027d\5^\60\2\u0279")
        buf.write("\u027d\5`\61\2\u027a\u027d\5b\62\2\u027b\u027d\5d\63\2")
        buf.write("\u027c\u0278\3\2\2\2\u027c\u0279\3\2\2\2\u027c\u027a\3")
        buf.write("\2\2\2\u027c\u027b\3\2\2\2\u027d]\3\2\2\2\u027e\u027f")
        buf.write("\7~\2\2\u027f\u0286\7I\2\2\u0280\u0282\5f\64\2\u0281\u0280")
        buf.write("\3\2\2\2\u0282\u0283\3\2\2\2\u0283\u0281\3\2\2\2\u0283")
        buf.write("\u0284\3\2\2\2\u0284\u0287\3\2\2\2\u0285\u0287\7F\2\2")
        buf.write("\u0286\u0281\3\2\2\2\u0286\u0285\3\2\2\2\u0287\u0288\3")
        buf.write("\2\2\2\u0288\u0289\7\177\2\2\u0289_\3\2\2\2\u028a\u028b")
        buf.write("\7~\2\2\u028b\u0292\7=\2\2\u028c\u028e\5\u00f2z\2\u028d")
        buf.write("\u028c\3\2\2\2\u028e\u028f\3\2\2\2\u028f\u028d\3\2\2\2")
        buf.write("\u028f\u0290\3\2\2\2\u0290\u0293\3\2\2\2\u0291\u0293\7")
        buf.write("F\2\2\u0292\u028d\3\2\2\2\u0292\u0291\3\2\2\2\u0293\u0294")
        buf.write("\3\2\2\2\u0294\u02ea\7\177\2\2\u0295\u0296\7~\2\2\u0296")
        buf.write("\u029d\7>\2\2\u0297\u0299\5\u00f4{\2\u0298\u0297\3\2\2")
        buf.write("\2\u0299\u029a\3\2\2\2\u029a\u0298\3\2\2\2\u029a\u029b")
        buf.write("\3\2\2\2\u029b\u029e\3\2\2\2\u029c\u029e\7F\2\2\u029d")
        buf.write("\u0298\3\2\2\2\u029d\u029c\3\2\2\2\u029e\u029f\3\2\2\2")
        buf.write("\u029f\u02ea\7\177\2\2\u02a0\u02a1\7~\2\2\u02a1\u02a8")
        buf.write("\7?\2\2\u02a2\u02a4\5\26\f\2\u02a3\u02a2\3\2\2\2\u02a4")
        buf.write("\u02a5\3\2\2\2\u02a5\u02a3\3\2\2\2\u02a5\u02a6\3\2\2\2")
        buf.write("\u02a6\u02a9\3\2\2\2\u02a7\u02a9\7F\2\2\u02a8\u02a3\3")
        buf.write("\2\2\2\u02a8\u02a7\3\2\2\2\u02a9\u02aa\3\2\2\2\u02aa\u02ea")
        buf.write("\7\177\2\2\u02ab\u02ac\7~\2\2\u02ac\u02b3\7@\2\2\u02ad")
        buf.write("\u02af\5\u00eex\2\u02ae\u02ad\3\2\2\2\u02af\u02b0\3\2")
        buf.write("\2\2\u02b0\u02ae\3\2\2\2\u02b0\u02b1\3\2\2\2\u02b1\u02b4")
        buf.write("\3\2\2\2\u02b2\u02b4\7F\2\2\u02b3\u02ae\3\2\2\2\u02b3")
        buf.write("\u02b2\3\2\2\2\u02b4\u02b5\3\2\2\2\u02b5\u02ea\7\177\2")
        buf.write("\2\u02b6\u02b7\7~\2\2\u02b7\u02be\7A\2\2\u02b8\u02ba\5")
        buf.write("\u00f0y\2\u02b9\u02b8\3\2\2\2\u02ba\u02bb\3\2\2\2\u02bb")
        buf.write("\u02b9\3\2\2\2\u02bb\u02bc\3\2\2\2\u02bc\u02bf\3\2\2\2")
        buf.write("\u02bd\u02bf\7F\2\2\u02be\u02b9\3\2\2\2\u02be\u02bd\3")
        buf.write("\2\2\2\u02bf\u02c0\3\2\2\2\u02c0\u02ea\7\177\2\2\u02c1")
        buf.write("\u02c2\7~\2\2\u02c2\u02c9\7B\2\2\u02c3\u02c5\5\f\7\2\u02c4")
        buf.write("\u02c3\3\2\2\2\u02c5\u02c6\3\2\2\2\u02c6\u02c4\3\2\2\2")
        buf.write("\u02c6\u02c7\3\2\2\2\u02c7\u02ca\3\2\2\2\u02c8\u02ca\7")
        buf.write("F\2\2\u02c9\u02c4\3\2\2\2\u02c9\u02c8\3\2\2\2\u02ca\u02cb")
        buf.write("\3\2\2\2\u02cb\u02ea\7\177\2\2\u02cc\u02cd\7~\2\2\u02cd")
        buf.write("\u02d4\7C\2\2\u02ce\u02d0\5\u00f6|\2\u02cf\u02ce\3\2\2")
        buf.write("\2\u02d0\u02d1\3\2\2\2\u02d1\u02cf\3\2\2\2\u02d1\u02d2")
        buf.write("\3\2\2\2\u02d2\u02d5\3\2\2\2\u02d3\u02d5\7F\2\2\u02d4")
        buf.write("\u02cf\3\2\2\2\u02d4\u02d3\3\2\2\2\u02d5\u02d6\3\2\2\2")
        buf.write("\u02d6\u02ea\7\177\2\2\u02d7\u02d8\7~\2\2\u02d8\u02db")
        buf.write("\7D\2\2\u02d9\u02dc\5h\65\2\u02da\u02dc\7F\2\2\u02db\u02d9")
        buf.write("\3\2\2\2\u02db\u02da\3\2\2\2\u02dc\u02dd\3\2\2\2\u02dd")
        buf.write("\u02ea\7\177\2\2\u02de\u02df\7~\2\2\u02df\u02e6\7E\2\2")
        buf.write("\u02e0\u02e2\5\u00f8}\2\u02e1\u02e0\3\2\2\2\u02e2\u02e3")
        buf.write("\3\2\2\2\u02e3\u02e1\3\2\2\2\u02e3\u02e4\3\2\2\2\u02e4")
        buf.write("\u02e7\3\2\2\2\u02e5\u02e7\7F\2\2\u02e6\u02e1\3\2\2\2")
        buf.write("\u02e6\u02e5\3\2\2\2\u02e7\u02e8\3\2\2\2\u02e8\u02ea\7")
        buf.write("\177\2\2\u02e9\u028a\3\2\2\2\u02e9\u0295\3\2\2\2\u02e9")
        buf.write("\u02a0\3\2\2\2\u02e9\u02ab\3\2\2\2\u02e9\u02b6\3\2\2\2")
        buf.write("\u02e9\u02c1\3\2\2\2\u02e9\u02cc\3\2\2\2\u02e9\u02d7\3")
        buf.write("\2\2\2\u02e9\u02de\3\2\2\2\u02eaa\3\2\2\2\u02eb\u02ec")
        buf.write("\7~\2\2\u02ec\u02ed\7G\2\2\u02ed\u02ee\5j\66\2\u02ee\u02ef")
        buf.write("\5j\66\2\u02ef\u02f0\7\177\2\2\u02f0c\3\2\2\2\u02f1\u02f2")
        buf.write("\7~\2\2\u02f2\u02f3\7H\2\2\u02f3\u02f4\5l\67\2\u02f4\u02f5")
        buf.write("\5l\67\2\u02f5\u02f6\7\177\2\2\u02f6e\3\2\2\2\u02f7\u02f8")
        buf.write("\t\6\2\2\u02f8g\3\2\2\2\u02f9\u02fa\5\u00f2z\2\u02fai")
        buf.write("\3\2\2\2\u02fb\u02fe\5\f\7\2\u02fc\u02fe\7F\2\2\u02fd")
        buf.write("\u02fb\3\2\2\2\u02fd\u02fc\3\2\2\2\u02fek\3\2\2\2\u02ff")
        buf.write("\u0302\5\u00eex\2\u0300\u0302\7F\2\2\u0301\u02ff\3\2\2")
        buf.write("\2\u0301\u0300\3\2\2\2\u0302m\3\2\2\2\u0303\u0304\7~\2")
        buf.write("\2\u0304\u0306\7\64\2\2\u0305\u0307\5\u00f2z\2\u0306\u0305")
        buf.write("\3\2\2\2\u0306\u0307\3\2\2\2\u0307\u030b\3\2\2\2\u0308")
        buf.write("\u030a\5p9\2\u0309\u0308\3\2\2\2\u030a\u030d\3\2\2\2\u030b")
        buf.write("\u0309\3\2\2\2\u030b\u030c\3\2\2\2\u030c\u030e\3\2\2\2")
        buf.write("\u030d\u030b\3\2\2\2\u030e\u030f\7\177\2\2\u030fo\3\2")
        buf.write("\2\2\u0310\u0311\7\u00a0\2\2\u0311\u0312\7\u0096\2\2\u0312")
        buf.write("\u0313\5\6\4\2\u0313q\3\2\2\2\u0314\u0315\7~\2\2\u0315")
        buf.write("\u0316\7\65\2\2\u0316\u0318\5t;\2\u0317\u0319\5\u00f4")
        buf.write("{\2\u0318\u0317\3\2\2\2\u0318\u0319\3\2\2\2\u0319\u031b")
        buf.write("\3\2\2\2\u031a\u031c\5v<\2\u031b\u031a\3\2\2\2\u031b\u031c")
        buf.write("\3\2\2\2\u031c\u0320\3\2\2\2\u031d\u031f\5z>\2\u031e\u031d")
        buf.write("\3\2\2\2\u031f\u0322\3\2\2\2\u0320\u031e\3\2\2\2\u0320")
        buf.write("\u0321\3\2\2\2\u0321\u0323\3\2\2\2\u0322\u0320\3\2\2\2")
        buf.write("\u0323\u0327\7\u0097\2\2\u0324\u0326\5\b\5\2\u0325\u0324")
        buf.write("\3\2\2\2\u0326\u0329\3\2\2\2\u0327\u0325\3\2\2\2\u0327")
        buf.write("\u0328\3\2\2\2\u0328\u032a\3\2\2\2\u0329\u0327\3\2\2\2")
        buf.write("\u032a\u032b\7\177\2\2\u032bs\3\2\2\2\u032c\u032d\5\u00f2")
        buf.write("z\2\u032du\3\2\2\2\u032e\u032f\7~\2\2\u032f\u0331\7%\2")
        buf.write("\2\u0330\u0332\5x=\2\u0331\u0330\3\2\2\2\u0332\u0333\3")
        buf.write("\2\2\2\u0333\u0331\3\2\2\2\u0333\u0334\3\2\2\2\u0334\u0335")
        buf.write("\3\2\2\2\u0335\u0336\7\177\2\2\u0336w\3\2\2\2\u0337\u0338")
        buf.write("\7~\2\2\u0338\u0339\7M\2\2\u0339\u033a\5\u00eex\2\u033a")
        buf.write("\u033b\7\177\2\2\u033b\u0342\3\2\2\2\u033c\u033d\7~\2")
        buf.write("\2\u033d\u033e\7N\2\2\u033e\u033f\5\u00fa~\2\u033f\u0340")
        buf.write("\7\177\2\2\u0340\u0342\3\2\2\2\u0341\u0337\3\2\2\2\u0341")
        buf.write("\u033c\3\2\2\2\u0342y\3\2\2\2\u0343\u034d\5|?\2\u0344")
        buf.write("\u034d\5~@\2\u0345\u034d\5\u0080A\2\u0346\u034d\5\u0082")
        buf.write("B\2\u0347\u034d\5\u0084C\2\u0348\u034d\5\u0086D\2\u0349")
        buf.write("\u034d\5\u0088E\2\u034a\u034d\5\u008aF\2\u034b\u034d\5")
        buf.write("\u008cG\2\u034c\u0343\3\2\2\2\u034c\u0344\3\2\2\2\u034c")
        buf.write("\u0345\3\2\2\2\u034c\u0346\3\2\2\2\u034c\u0347\3\2\2\2")
        buf.write("\u034c\u0348\3\2\2\2\u034c\u0349\3\2\2\2\u034c\u034a\3")
        buf.write("\2\2\2\u034c\u034b\3\2\2\2\u034d{\3\2\2\2\u034e\u0352")
        buf.write("\5\u008eH\2\u034f\u0352\5\u009eP\2\u0350\u0352\5\u00a2")
        buf.write("R\2\u0351\u034e\3\2\2\2\u0351\u034f\3\2\2\2\u0351\u0350")
        buf.write("\3\2\2\2\u0352}\3\2\2\2\u0353\u0354\7\u00a1\2\2\u0354")
        buf.write("\u0355\7\u0093\2\2\u0355\u0356\5|?\2\u0356\177\3\2\2\2")
        buf.write("\u0357\u0358\7~\2\2\u0358\u0359\7#\2\2\u0359\u035a\5z")
        buf.write(">\2\u035a\u035b\7\177\2\2\u035b\u0081\3\2\2\2\u035c\u035d")
        buf.write("\7~\2\2\u035d\u035f\7!\2\2\u035e\u0360\5z>\2\u035f\u035e")
        buf.write("\3\2\2\2\u0360\u0361\3\2\2\2\u0361\u035f\3\2\2\2\u0361")
        buf.write("\u0362\3\2\2\2\u0362\u0363\3\2\2\2\u0363\u0364\7\177\2")
        buf.write("\2\u0364\u0083\3\2\2\2\u0365\u0366\7~\2\2\u0366\u0368")
        buf.write("\7\36\2\2\u0367\u0369\5z>\2\u0368\u0367\3\2\2\2\u0369")
        buf.write("\u036a\3\2\2\2\u036a\u0368\3\2\2\2\u036a\u036b\3\2\2\2")
        buf.write("\u036b\u036c\3\2\2\2\u036c\u036d\7\177\2\2\u036d\u0085")
        buf.write("\3\2\2\2\u036e\u036f\7~\2\2\u036f\u0371\7&\2\2\u0370\u0372")
        buf.write("\5z>\2\u0371\u0370\3\2\2\2\u0372\u0373\3\2\2\2\u0373\u0371")
        buf.write("\3\2\2\2\u0373\u0374\3\2\2\2\u0374\u0375\3\2\2\2\u0375")
        buf.write("\u0376\7\177\2\2\u0376\u0087\3\2\2\2\u0377\u0378\7~\2")
        buf.write("\2\u0378\u0379\7\"\2\2\u0379\u037a\5 \21\2\u037a\u037b")
        buf.write("\7\177\2\2\u037b\u0089\3\2\2\2\u037c\u037d\7~\2\2\u037d")
        buf.write("\u037f\7(\2\2\u037e\u0380\5z>\2\u037f\u037e\3\2\2\2\u0380")
        buf.write("\u0381\3\2\2\2\u0381\u037f\3\2\2\2\u0381\u0382\3\2\2\2")
        buf.write("\u0382\u0383\3\2\2\2\u0383\u0384\7\177\2\2\u0384\u008b")
        buf.write("\3\2\2\2\u0385\u0386\7~\2\2\u0386\u0387\7)\2\2\u0387\u0389")
        buf.write("\5z>\2\u0388\u038a\5z>\2\u0389\u0388\3\2\2\2\u038a\u038b")
        buf.write("\3\2\2\2\u038b\u0389\3\2\2\2\u038b\u038c\3\2\2\2\u038c")
        buf.write("\u038d\3\2\2\2\u038d\u038e\7\177\2\2\u038e\u008d\3\2\2")
        buf.write("\2\u038f\u0390\7~\2\2\u0390\u0394\5\u00f2z\2\u0391\u0393")
        buf.write("\5\u0090I\2\u0392\u0391\3\2\2\2\u0393\u0396\3\2\2\2\u0394")
        buf.write("\u0392\3\2\2\2\u0394\u0395\3\2\2\2\u0395\u0397\3\2\2\2")
        buf.write("\u0396\u0394\3\2\2\2\u0397\u0398\7\177\2\2\u0398\u008f")
        buf.write("\3\2\2\2\u0399\u039d\7\u0083\2\2\u039a\u039d\7\u008e\2")
        buf.write("\2\u039b\u039d\5\u0092J\2\u039c\u0399\3\2\2\2\u039c\u039a")
        buf.write("\3\2\2\2\u039c\u039b\3\2\2\2\u039d\u0091\3\2\2\2\u039e")
        buf.write("\u03a8\5\u0094K\2\u039f\u03a0\5\u0094K\2\u03a0\u03a1\7")
        buf.write("\u008c\2\2\u03a1\u03a2\5\u0092J\2\u03a2\u03a8\3\2\2\2")
        buf.write("\u03a3\u03a4\5\u0094K\2\u03a4\u03a5\7\u008f\2\2\u03a5")
        buf.write("\u03a6\5\u0092J\2\u03a6\u03a8\3\2\2\2\u03a7\u039e\3\2")
        buf.write("\2\2\u03a7\u039f\3\2\2\2\u03a7\u03a3\3\2\2\2\u03a8\u0093")
        buf.write("\3\2\2\2\u03a9\u03ad\5\u0096L\2\u03aa\u03ab\7\u0090\2")
        buf.write("\2\u03ab\u03ad\5\u0096L\2\u03ac\u03a9\3\2\2\2\u03ac\u03aa")
        buf.write("\3\2\2\2\u03ad\u0095\3\2\2\2\u03ae\u03b6\5\u00f8}\2\u03af")
        buf.write("\u03b6\7\u00a1\2\2\u03b0\u03b6\7\u00a2\2\2\u03b1\u03b2")
        buf.write("\7\u0094\2\2\u03b2\u03b6\5 \21\2\u03b3\u03b4\7\u0096\2")
        buf.write("\2\u03b4\u03b6\5 \21\2\u03b5\u03ae\3\2\2\2\u03b5\u03af")
        buf.write("\3\2\2\2\u03b5\u03b0\3\2\2\2\u03b5\u03b1\3\2\2\2\u03b5")
        buf.write("\u03b3\3\2\2\2\u03b6\u0097\3\2\2\2\u03b7\u03b8\7~\2\2")
        buf.write("\u03b8\u03b9\5\u00f2z\2\u03b9\u03ba\5\u0090I\2\u03ba\u03bb")
        buf.write("\7\177\2\2\u03bb\u0099\3\2\2\2\u03bc\u03bd\7~\2\2\u03bd")
        buf.write("\u03c1\5\u00f2z\2\u03be\u03c0\5\u0090I\2\u03bf\u03be\3")
        buf.write("\2\2\2\u03c0\u03c3\3\2\2\2\u03c1\u03bf\3\2\2\2\u03c1\u03c2")
        buf.write("\3\2\2\2\u03c2\u03c4\3\2\2\2\u03c3\u03c1\3\2\2\2\u03c4")
        buf.write("\u03c5\7\177\2\2\u03c5\u009b\3\2\2\2\u03c6\u03c9\5\u0098")
        buf.write("M\2\u03c7\u03c9\5\u009aN\2\u03c8\u03c6\3\2\2\2\u03c8\u03c7")
        buf.write("\3\2\2\2\u03c9\u009d\3\2\2\2\u03ca\u03cb\7~\2\2\u03cb")
        buf.write("\u03cf\5\u00f2z\2\u03cc\u03ce\5\u009cO\2\u03cd\u03cc\3")
        buf.write("\2\2\2\u03ce\u03d1\3\2\2\2\u03cf\u03cd\3\2\2\2\u03cf\u03d0")
        buf.write("\3\2\2\2\u03d0\u03d2\3\2\2\2\u03d1\u03cf\3\2\2\2\u03d2")
        buf.write("\u03d3\7\177\2\2\u03d3\u009f\3\2\2\2\u03d4\u03d5\7~\2")
        buf.write("\2\u03d5\u03d6\7O\2\2\u03d6\u03d7\5\u0090I\2\u03d7\u03d8")
        buf.write("\7\177\2\2\u03d8\u03e4\3\2\2\2\u03d9\u03da\7~\2\2\u03da")
        buf.write("\u03de\5\u00f2z\2\u03db\u03dd\5\u0090I\2\u03dc\u03db\3")
        buf.write("\2\2\2\u03dd\u03e0\3\2\2\2\u03de\u03dc\3\2\2\2\u03de\u03df")
        buf.write("\3\2\2\2\u03df\u03e1\3\2\2\2\u03e0\u03de\3\2\2\2\u03e1")
        buf.write("\u03e2\7\177\2\2\u03e2\u03e4\3\2\2\2\u03e3\u03d4\3\2\2")
        buf.write("\2\u03e3\u03d9\3\2\2\2\u03e4\u00a1\3\2\2\2\u03e5\u03e6")
        buf.write("\7~\2\2\u03e6\u03ea\7\'\2\2\u03e7\u03e9\5\u00a0Q\2\u03e8")
        buf.write("\u03e7\3\2\2\2\u03e9\u03ec\3\2\2\2\u03ea\u03e8\3\2\2\2")
        buf.write("\u03ea\u03eb\3\2\2\2\u03eb\u03ed\3\2\2\2\u03ec\u03ea\3")
        buf.write("\2\2\2\u03ed\u03ee\7\177\2\2\u03ee\u00a3\3\2\2\2\u03ef")
        buf.write("\u03f0\7~\2\2\u03f0\u03f1\7\67\2\2\u03f1\u03f3\5\u00f2")
        buf.write("z\2\u03f2\u03f4\5\u00f4{\2\u03f3\u03f2\3\2\2\2\u03f3\u03f4")
        buf.write("\3\2\2\2\u03f4\u03f8\3\2\2\2\u03f5\u03f7\5\u00a6T\2\u03f6")
        buf.write("\u03f5\3\2\2\2\u03f7\u03fa\3\2\2\2\u03f8\u03f6\3\2\2\2")
        buf.write("\u03f8\u03f9\3\2\2\2\u03f9\u03fb\3\2\2\2\u03fa\u03f8\3")
        buf.write("\2\2\2\u03fb\u03fc\7\177\2\2\u03fc\u00a5\3\2\2\2\u03fd")
        buf.write("\u03fe\7~\2\2\u03fe\u03ff\7Q\2\2\u03ff\u0400\5\u00a8U")
        buf.write("\2\u0400\u0401\7\177\2\2\u0401\u0409\3\2\2\2\u0402\u0403")
        buf.write("\7~\2\2\u0403\u0404\7R\2\2\u0404\u0405\5\u00f2z\2\u0405")
        buf.write("\u0406\5\u00a8U\2\u0406\u0407\7\177\2\2\u0407\u0409\3")
        buf.write("\2\2\2\u0408\u03fd\3\2\2\2\u0408\u0402\3\2\2\2\u0409\u00a7")
        buf.write("\3\2\2\2\u040a\u0419\7S\2\2\u040b\u0419\7K\2\2\u040c\u040d")
        buf.write("\5\u00aaV\2\u040d\u040e\7S\2\2\u040e\u0419\3\2\2\2\u040f")
        buf.write("\u0410\5\u00aaV\2\u0410\u0411\7K\2\2\u0411\u0419\3\2\2")
        buf.write("\2\u0412\u0414\5\u00aaV\2\u0413\u0415\5\u00f2z\2\u0414")
        buf.write("\u0413\3\2\2\2\u0415\u0416\3\2\2\2\u0416\u0414\3\2\2\2")
        buf.write("\u0416\u0417\3\2\2\2\u0417\u0419\3\2\2\2\u0418\u040a\3")
        buf.write("\2\2\2\u0418\u040b\3\2\2\2\u0418\u040c\3\2\2\2\u0418\u040f")
        buf.write("\3\2\2\2\u0418\u0412\3\2\2\2\u0419\u00a9\3\2\2\2\u041a")
        buf.write("\u041b\t\7\2\2\u041b\u00ab\3\2\2\2\u041c\u041d\7~\2\2")
        buf.write("\u041d\u041e\7\66\2\2\u041e\u0420\5\u00f2z\2\u041f\u0421")
        buf.write("\5\u00f4{\2\u0420\u041f\3\2\2\2\u0420\u0421\3\2\2\2\u0421")
        buf.write("\u0422\3\2\2\2\u0422\u0426\5\u00aeX\2\u0423\u0425\5\b")
        buf.write("\5\2\u0424\u0423\3\2\2\2\u0425\u0428\3\2\2\2\u0426\u0424")
        buf.write("\3\2\2\2\u0426\u0427\3\2\2\2\u0427\u0429\3\2\2\2\u0428")
        buf.write("\u0426\3\2\2\2\u0429\u042a\7\177\2\2\u042a\u00ad\3\2\2")
        buf.write("\2\u042b\u042f\7~\2\2\u042c\u042e\5\u00b0Y\2\u042d\u042c")
        buf.write("\3\2\2\2\u042e\u0431\3\2\2\2\u042f\u042d\3\2\2\2\u042f")
        buf.write("\u0430\3\2\2\2\u0430\u0433\3\2\2\2\u0431\u042f\3\2\2\2")
        buf.write("\u0432\u0434\5\u00b2Z\2\u0433\u0432\3\2\2\2\u0433\u0434")
        buf.write("\3\2\2\2\u0434\u0435\3\2\2\2\u0435\u0436\7\177\2\2\u0436")
        buf.write("\u00af\3\2\2\2\u0437\u0438\7\u00a1\2\2\u0438\u00b1\3\2")
        buf.write("\2\2\u0439\u043a\7\u00a2\2\2\u043a\u00b3\3\2\2\2\u043b")
        buf.write("\u043c\7~\2\2\u043c\u043d\79\2\2\u043d\u043f\5\u00f2z")
        buf.write("\2\u043e\u0440\5\u00f4{\2\u043f\u043e\3\2\2\2\u043f\u0440")
        buf.write("\3\2\2\2\u0440\u0441\3\2\2\2\u0441\u0442\7~\2\2\u0442")
        buf.write("\u0444\7O\2\2\u0443\u0445\5\u00f2z\2\u0444\u0443\3\2\2")
        buf.write("\2\u0445\u0446\3\2\2\2\u0446\u0444\3\2\2\2\u0446\u0447")
        buf.write("\3\2\2\2\u0447\u0448\3\2\2\2\u0448\u044a\7\177\2\2\u0449")
        buf.write("\u044b\5\u00b6\\\2\u044a\u0449\3\2\2\2\u044a\u044b\3\2")
        buf.write("\2\2\u044b\u044d\3\2\2\2\u044c\u044e\5\u00b8]\2\u044d")
        buf.write("\u044c\3\2\2\2\u044d\u044e\3\2\2\2\u044e\u0452\3\2\2\2")
        buf.write("\u044f\u0451\5\u00ba^\2\u0450\u044f\3\2\2\2\u0451\u0454")
        buf.write("\3\2\2\2\u0452\u0450\3\2\2\2\u0452\u0453\3\2\2\2\u0453")
        buf.write("\u0458\3\2\2\2\u0454\u0452\3\2\2\2\u0455\u0457\5\u00d0")
        buf.write("i\2\u0456\u0455\3\2\2\2\u0457\u045a\3\2\2\2\u0458\u0456")
        buf.write("\3\2\2\2\u0458\u0459\3\2\2\2\u0459\u045b\3\2\2\2\u045a")
        buf.write("\u0458\3\2\2\2\u045b\u045c\7\177\2\2\u045c\u00b5\3\2\2")
        buf.write("\2\u045d\u045e\7~\2\2\u045e\u045f\7T\2\2\u045f\u0460\t")
        buf.write("\b\2\2\u0460\u0461\7\177\2\2\u0461\u00b7\3\2\2\2\u0462")
        buf.write("\u0463\7~\2\2\u0463\u0464\7W\2\2\u0464\u0465\t\t\2\2\u0465")
        buf.write("\u0466\7\177\2\2\u0466\u00b9\3\2\2\2\u0467\u0468\7~\2")
        buf.write("\2\u0468\u0469\7;\2\2\u0469\u046d\5\u00f2z\2\u046a\u046c")
        buf.write("\5\u00bc_\2\u046b\u046a\3\2\2\2\u046c\u046f\3\2\2\2\u046d")
        buf.write("\u046b\3\2\2\2\u046d\u046e\3\2\2\2\u046e\u0470\3\2\2\2")
        buf.write("\u046f\u046d\3\2\2\2\u0470\u0471\7\177\2\2\u0471\u0489")
        buf.write("\3\2\2\2\u0472\u0473\7~\2\2\u0473\u0474\7Z\2\2\u0474\u0478")
        buf.write("\5\u00f2z\2\u0475\u0477\5\u00bc_\2\u0476\u0475\3\2\2\2")
        buf.write("\u0477\u047a\3\2\2\2\u0478\u0476\3\2\2\2\u0478\u0479\3")
        buf.write("\2\2\2\u0479\u047b\3\2\2\2\u047a\u0478\3\2\2\2\u047b\u047c")
        buf.write("\7\177\2\2\u047c\u0489\3\2\2\2\u047d\u047e\7~\2\2\u047e")
        buf.write("\u047f\7<\2\2\u047f\u0483\5\u00f2z\2\u0480\u0482\5\u00bc")
        buf.write("_\2\u0481\u0480\3\2\2\2\u0482\u0485\3\2\2\2\u0483\u0481")
        buf.write("\3\2\2\2\u0483\u0484\3\2\2\2\u0484\u0486\3\2\2\2\u0485")
        buf.write("\u0483\3\2\2\2\u0486\u0487\7\177\2\2\u0487\u0489\3\2\2")
        buf.write("\2\u0488\u0467\3\2\2\2\u0488\u0472\3\2\2\2\u0488\u047d")
        buf.write("\3\2\2\2\u0489\u00bb\3\2\2\2\u048a\u0496\5\u00be`\2\u048b")
        buf.write("\u0496\5\\/\2\u048c\u0496\5X-\2\u048d\u0496\5\u00c0a\2")
        buf.write("\u048e\u0496\5\u00c2b\2\u048f\u0496\5\u00c4c\2\u0490\u0496")
        buf.write("\5\u00c6d\2\u0491\u0496\5\u00c8e\2\u0492\u0496\5\u00ca")
        buf.write("f\2\u0493\u0496\5\u00ccg\2\u0494\u0496\5\u00ceh\2\u0495")
        buf.write("\u048a\3\2\2\2\u0495\u048b\3\2\2\2\u0495\u048c\3\2\2\2")
        buf.write("\u0495\u048d\3\2\2\2\u0495\u048e\3\2\2\2\u0495\u048f\3")
        buf.write("\2\2\2\u0495\u0490\3\2\2\2\u0495\u0491\3\2\2\2\u0495\u0492")
        buf.write("\3\2\2\2\u0495\u0493\3\2\2\2\u0495\u0494\3\2\2\2\u0496")
        buf.write("\u00bd\3\2\2\2\u0497\u0498\7~\2\2\u0498\u04a1\7,\2\2\u0499")
        buf.write("\u04a2\7J\2\2\u049a\u04a2\7K\2\2\u049b\u049d\5\6\4\2\u049c")
        buf.write("\u049b\3\2\2\2\u049d\u04a0\3\2\2\2\u049e\u049c\3\2\2\2")
        buf.write("\u049e\u049f\3\2\2\2\u049f\u04a2\3\2\2\2\u04a0\u049e\3")
        buf.write("\2\2\2\u04a1\u0499\3\2\2\2\u04a1\u049a\3\2\2\2\u04a1\u049e")
        buf.write("\3\2\2\2\u04a2\u04a3\3\2\2\2\u04a3\u04ae\7\177\2\2\u04a4")
        buf.write("\u04a5\7~\2\2\u04a5\u04a9\7L\2\2\u04a6\u04a8\5\6\4\2\u04a7")
        buf.write("\u04a6\3\2\2\2\u04a8\u04ab\3\2\2\2\u04a9\u04a7\3\2\2\2")
        buf.write("\u04a9\u04aa\3\2\2\2\u04aa\u04ac\3\2\2\2\u04ab\u04a9\3")
        buf.write("\2\2\2\u04ac\u04ae\7\177\2\2\u04ad\u0497\3\2\2\2\u04ad")
        buf.write("\u04a4\3\2\2\2\u04ae\u00bf\3\2\2\2\u04af\u04b0\7~\2\2")
        buf.write("\u04b0\u04b1\7[\2\2\u04b1\u04b2\t\n\2\2\u04b2\u04b3\7")
        buf.write("\177\2\2\u04b3\u00c1\3\2\2\2\u04b4\u04b5\7~\2\2\u04b5")
        buf.write("\u04b6\7^\2\2\u04b6\u04b7\t\13\2\2\u04b7\u04b8\7\177\2")
        buf.write("\2\u04b8\u00c3\3\2\2\2\u04b9\u04ba\7~\2\2\u04ba\u04bb")
        buf.write("\7b\2\2\u04bb\u04bc\t\f\2\2\u04bc\u04bd\7\177\2\2\u04bd")
        buf.write("\u00c5\3\2\2\2\u04be\u04bf\7~\2\2\u04bf\u04c0\7e\2\2\u04c0")
        buf.write("\u04c1\t\r\2\2\u04c1\u04c2\7\177\2\2\u04c2\u00c7\3\2\2")
        buf.write("\2\u04c3\u04c4\7~\2\2\u04c4\u04c5\7W\2\2\u04c5\u04c6\t")
        buf.write("\t\2\2\u04c6\u04c7\7\177\2\2\u04c7\u00c9\3\2\2\2\u04c8")
        buf.write("\u04c9\7~\2\2\u04c9\u04ca\7h\2\2\u04ca\u04cb\t\16\2\2")
        buf.write("\u04cb\u04cc\7\177\2\2\u04cc\u00cb\3\2\2\2\u04cd\u04ce")
        buf.write("\7~\2\2\u04ce\u04cf\7k\2\2\u04cf\u04d0\t\17\2\2\u04d0")
        buf.write("\u04d1\7\177\2\2\u04d1\u00cd\3\2\2\2\u04d2\u04d3\7~\2")
        buf.write("\2\u04d3\u04d6\7n\2\2\u04d4\u04d7\7-\2\2\u04d5\u04d7\5")
        buf.write("\u00f2z\2\u04d6\u04d4\3\2\2\2\u04d6\u04d5\3\2\2\2\u04d7")
        buf.write("\u04d8\3\2\2\2\u04d8\u04d9\7\177\2\2\u04d9\u00cf\3\2\2")
        buf.write("\2\u04da\u04db\7~\2\2\u04db\u04dc\7o\2\2\u04dc\u04de\5")
        buf.write("\u00f2z\2\u04dd\u04df\5\u00d2j\2\u04de\u04dd\3\2\2\2\u04de")
        buf.write("\u04df\3\2\2\2\u04df\u04e0\3\2\2\2\u04e0\u04e1\7\177\2")
        buf.write("\2\u04e1\u00d1\3\2\2\2\u04e2\u04e3\t\20\2\2\u04e3\u00d3")
        buf.write("\3\2\2\2\u04e4\u04e5\7~\2\2\u04e5\u04e6\78\2\2\u04e6\u04e8")
        buf.write("\5\u00f2z\2\u04e7\u04e9\5\u00f4{\2\u04e8\u04e7\3\2\2\2")
        buf.write("\u04e8\u04e9\3\2\2\2\u04e9\u04ea\3\2\2\2\u04ea\u04eb\7")
        buf.write("\177\2\2\u04eb\u00d5\3\2\2\2\u04ec\u04ed\7~\2\2\u04ed")
        buf.write("\u04ee\7:\2\2\u04ee\u04f0\5\u00f2z\2\u04ef\u04f1\7P\2")
        buf.write("\2\u04f0\u04ef\3\2\2\2\u04f0\u04f1\3\2\2\2\u04f1\u04f3")
        buf.write("\3\2\2\2\u04f2\u04f4\5\u00f4{\2\u04f3\u04f2\3\2\2\2\u04f3")
        buf.write("\u04f4\3\2\2\2\u04f4\u04f8\3\2\2\2\u04f5\u04f7\5\u00d8")
        buf.write("m\2\u04f6\u04f5\3\2\2\2\u04f7\u04fa\3\2\2\2\u04f8\u04f6")
        buf.write("\3\2\2\2\u04f8\u04f9\3\2\2\2\u04f9\u04fb\3\2\2\2\u04fa")
        buf.write("\u04f8\3\2\2\2\u04fb\u04fc\7\177\2\2\u04fc\u00d7\3\2\2")
        buf.write("\2\u04fd\u04fe\7~\2\2\u04fe\u04ff\5\u00dan\2\u04ff\u0500")
        buf.write("\7\177\2\2\u0500\u00d9\3\2\2\2\u0501\u0503\5\u00f2z\2")
        buf.write("\u0502\u0501\3\2\2\2\u0502\u0503\3\2\2\2\u0503\u0504\3")
        buf.write("\2\2\2\u0504\u0505\7t\2\2\u0505\u0509\5h\65\2\u0506\u0508")
        buf.write("\5\u00dco\2\u0507\u0506\3\2\2\2\u0508\u050b\3\2\2\2\u0509")
        buf.write("\u0507\3\2\2\2\u0509\u050a\3\2\2\2\u050a\u00db\3\2\2\2")
        buf.write("\u050b\u0509\3\2\2\2\u050c\u050d\7~\2\2\u050d\u0511\5")
        buf.write("\u00f2z\2\u050e\u0510\5\6\4\2\u050f\u050e\3\2\2\2\u0510")
        buf.write("\u0513\3\2\2\2\u0511\u050f\3\2\2\2\u0511\u0512\3\2\2\2")
        buf.write("\u0512\u0514\3\2\2\2\u0513\u0511\3\2\2\2\u0514\u0515\7")
        buf.write("\177\2\2\u0515\u00dd\3\2\2\2\u0516\u051b\5\u00e0q\2\u0517")
        buf.write("\u051b\5\u00e2r\2\u0518\u051b\5\u00e4s\2\u0519\u051b\5")
        buf.write("\u00ecw\2\u051a\u0516\3\2\2\2\u051a\u0517\3\2\2\2\u051a")
        buf.write("\u0518\3\2\2\2\u051a\u0519\3\2\2\2\u051b\u00df\3\2\2\2")
        buf.write("\u051c\u051d\7~\2\2\u051d\u051e\7u\2\2\u051e\u051f\5\u00e8")
        buf.write("u\2\u051f\u0520\5\u00e6t\2\u0520\u0521\7\177\2\2\u0521")
        buf.write("\u00e1\3\2\2\2\u0522\u0523\7~\2\2\u0523\u0524\t\21\2\2")
        buf.write("\u0524\u0525\5\u00e8u\2\u0525\u0526\5\u00e6t\2\u0526\u0527")
        buf.write("\7\177\2\2\u0527\u00e3\3\2\2\2\u0528\u0529\7~\2\2\u0529")
        buf.write("\u052a\t\22\2\2\u052a\u052b\5\u00e8u\2\u052b\u052f\5\u00e6")
        buf.write("t\2\u052c\u052e\5\b\5\2\u052d\u052c\3\2\2\2\u052e\u0531")
        buf.write("\3\2\2\2\u052f\u052d\3\2\2\2\u052f\u0530\3\2\2\2\u0530")
        buf.write("\u0532\3\2\2\2\u0531\u052f\3\2\2\2\u0532\u0533\7\177\2")
        buf.write("\2\u0533\u00e5\3\2\2\2\u0534\u0538\5\6\4\2\u0535\u0538")
        buf.write("\7/\2\2\u0536\u0538\7\60\2\2\u0537\u0534\3\2\2\2\u0537")
        buf.write("\u0535\3\2\2\2\u0537\u0536\3\2\2\2\u0538\u00e7\3\2\2\2")
        buf.write("\u0539\u053b\7~\2\2\u053a\u053c\5\u00eav\2\u053b\u053a")
        buf.write("\3\2\2\2\u053c\u053d\3\2\2\2\u053d\u053b\3\2\2\2\u053d")
        buf.write("\u053e\3\2\2\2\u053e\u053f\3\2\2\2\u053f\u0540\7\177\2")
        buf.write("\2\u0540\u00e9\3\2\2\2\u0541\u0542\7~\2\2\u0542\u0544")
        buf.write("\7\u00a1\2\2\u0543\u0545\5h\65\2\u0544\u0543\3\2\2\2\u0545")
        buf.write("\u0546\3\2\2\2\u0546\u0544\3\2\2\2\u0546\u0547\3\2\2\2")
        buf.write("\u0547\u0548\3\2\2\2\u0548\u0549\7\177\2\2\u0549\u00eb")
        buf.write("\3\2\2\2\u054a\u054b\7~\2\2\u054b\u054c\t\23\2\2\u054c")
        buf.write("\u054d\5\u00dan\2\u054d\u054e\7\177\2\2\u054e\u00ed\3")
        buf.write("\2\2\2\u054f\u0550\7\u0098\2\2\u0550\u00ef\3\2\2\2\u0551")
        buf.write("\u0552\7\u0099\2\2\u0552\u00f1\3\2\2\2\u0553\u0557\5\u00fa")
        buf.write("~\2\u0554\u0557\7p\2\2\u0555\u0557\7\u009b\2\2\u0556\u0553")
        buf.write("\3\2\2\2\u0556\u0554\3\2\2\2\u0556\u0555\3\2\2\2\u0557")
        buf.write("\u00f3\3\2\2\2\u0558\u0559\7\u009c\2\2\u0559\u00f5\3\2")
        buf.write("\2\2\u055a\u055b\7\u009a\2\2\u055b\u00f7\3\2\2\2\u055c")
        buf.write("\u0562\5\u00eex\2\u055d\u0562\5\u00f0y\2\u055e\u0562\5")
        buf.write("\u00f2z\2\u055f\u0562\5\u00f4{\2\u0560\u0562\5\u00f6|")
        buf.write("\2\u0561\u055c\3\2\2\2\u0561\u055d\3\2\2\2\u0561\u055e")
        buf.write("\3\2\2\2\u0561\u055f\3\2\2\2\u0561\u0560\3\2\2\2\u0562")
        buf.write("\u00f9\3\2\2\2\u0563\u0564\t\24\2\2\u0564\u00fb\3\2\2")
        buf.write("\2\u008a\u00fe\u0100\u010c\u0119\u011d\u0124\u012a\u0136")
        buf.write("\u013a\u014a\u0151\u015b\u0165\u016f\u017a\u0182\u0189")
        buf.write("\u0190\u0193\u019b\u01a0\u01ab\u01af\u01ba\u01c3\u01c8")
        buf.write("\u01d0\u01df\u01e9\u01fa\u0200\u0205\u020f\u021a\u0226")
        buf.write("\u022e\u0232\u0238\u023d\u0244\u024c\u0257\u025e\u0267")
        buf.write("\u026a\u0272\u0276\u027c\u0283\u0286\u028f\u0292\u029a")
        buf.write("\u029d\u02a5\u02a8\u02b0\u02b3\u02bb\u02be\u02c6\u02c9")
        buf.write("\u02d1\u02d4\u02db\u02e3\u02e6\u02e9\u02fd\u0301\u0306")
        buf.write("\u030b\u0318\u031b\u0320\u0327\u0333\u0341\u034c\u0351")
        buf.write("\u0361\u036a\u0373\u0381\u038b\u0394\u039c\u03a7\u03ac")
        buf.write("\u03b5\u03c1\u03c8\u03cf\u03de\u03e3\u03ea\u03f3\u03f8")
        buf.write("\u0408\u0416\u0418\u0420\u0426\u042f\u0433\u043f\u0446")
        buf.write("\u044a\u044d\u0452\u0458\u046d\u0478\u0483\u0488\u0495")
        buf.write("\u049e\u04a1\u04a9\u04ad\u04d6\u04de\u04e8\u04f0\u04f3")
        buf.write("\u04f8\u0502\u0509\u0511\u051a\u052f\u0537\u053d\u0546")
        buf.write("\u0556\u0561")
        return buf.getvalue()


class clipsparser(Parser):
    grammarFileName = "clipsparser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "'float'", "'integer'", "'symbol'", "'string'",
                    "'address'", "'instance'", "'external'", "'fact'",
                    "'FLOAT'", "'INTEGER'", "'SYMBOL'", "'INSTANCE'", "'STRING'",
                    "'LEXEME'", "'NUMBER'", "'INSTANCE-NAME'", "'INSTANCE-ADDRESS'",
                    "'EXTERNAL-ADDRESS'", "'FACT-ADDRESS'", "'while'",
                    "'do'", "'if'", "'then'", "'else'", "'return'", "'switch'",
                    "'foreach'", "'or'", "'eq'", "'neq'", "'and'", "'test'",
                    "'not'", "'mod'", "'declare'", "'logical'", "'object'",
                    "'exists'", "'forall'", "'break'", "'case'", "'default'",
                    "'?DEFAULT'", "'loop-for-count'", "'TRUE'", "'FALSE'",
                    "'NULL'", "'deffacts'", "'deftemplate'", "'defglobal'",
                    "'defrule'", "'deffunction'", "'defmodule'", "'defgeneric'",
                    "'defclass'", "'definstances'", "'slot'", "'multislot'",
                    "'allowed-symbols'", "'allowed-strings'", "'allowed-lexemes'",
                    "'allowed-integers'", "'allowed-floats'", "'allowed-numbers'",
                    "'allowed-instances-names'", "'allowed-classes'", "'allowed-values'",
                    "'?VARIABLE'", "'range'", "'cardinality'", "'type'",
                    "'?DERIVE'", "'?NONE'", "'default-dynamic'", "'salience'",
                    "'auto-focus'", "'is-a'", "'active'", "'export'", "'import'",
                    "'?ALL'", "'role'", "'concrete'", "'abstract'", "'pattern-match'",
                    "'reactive'", "'non-reactive'", "'single-slot'", "'storage'",
                    "'local'", "'shared'", "'access'", "'read-write'",
                    "'read-only'", "'initialize-only'", "'propagation'",
                    "'inherit'", "'no-inherit'", "'source'", "'exclusive'",
                    "'composite'", "'visibility'", "'private'", "'public'",
                    "'create-accessor'", "'read'", "'write'", "'override-message'",
                    "'message-handler'", "'primary'", "'around'", "'before'",
                    "'after'", "'of'", "'any-instancep'", "'find-instance'",
                    "'find-all-instances'", "'do-for-instance'", "'do-for-all-instances'",
                    "'delayed-do-for-all-instances'", "'make-instance'",
                    "'active-make-instance'", "'...'", "'('", "')'", "'['",
                    "']'", "'<'", "'?'", "'<='", "'>'", "'>='", "'<>'",
                    "'+'", "'-'", "'*'", "'**'", "'&'", "'$'", "'$?'",
                    "'|'", "'~'", "'/'", "'div'", "'<-'", "':'", "';'",
                    "'='", "'=>'"]

    symbolicNames = ["<INVALID>", "FLOAT", "INTEGER", "SYMBOL", "STRING",
                     "ADDRESS", "INSTANCE", "EXTERNAL", "FACT", "CAPFLOAT",
                     "CAPINTEGER", "CAPSYMBOL", "CAPINSTANCE", "CAPSTRING",
                     "LEXEME", "NUMBER", "INSTANCENAME", "INSTANCEADDRESS",
                     "EXTERNALADDRESS", "FACTADDRESS", "WHILE", "DO", "IF",
                     "THEN", "ELSE", "RETURN", "SWITCH", "FOREACH", "OR",
                     "EQ", "NEQ", "AND", "TEST", "NOT", "MOD", "DECLARE",
                     "LOGICAL", "OBJECT", "EXISTS", "FORALL", "BREAK",
                     "CASE", "DEFAULT", "CAPDEFAULT", "LOOPFORCOUNT", "TRUE",
                     "FALSE", "NULL", "DEFFACT", "DEFTEMPLATE", "DEFGLOBAL",
                     "DEFRULE", "DEFFUNCTION", "DEFMODULE", "DEFGENERIC",
                     "DEFCLASS", "DEFINSTANCES", "SLOT", "MULTISLOT", "ALLOWEDSYMBOLS",
                     "ALLOWEDSTRINGS", "ALLOWEDLEXEMES", "ALLOWEDINTEGERS",
                     "ALLOWEDFLOATS", "ALLOWEDNUMBERS", "ALLOWEDINSTANCESNAMES",
                     "ALLOWEDCLASSES", "ALLOWEDVALUES", "VARIABLE", "RANGE",
                     "CARDINALITY", "TYPE", "DERIVE", "NONE", "DEFAULTDYNAMIC",
                     "SALIENCE", "AUTOFOCUS", "ISA", "ACTIVE", "EXPORT",
                     "IMPORT", "ALL", "ROLE", "CONCRETE", "ABSTRACT", "PATTERNMATCH",
                     "REACTIVE", "NONREACTIVE", "SINGLESLOT", "STORAGE",
                     "LOCAL", "SHARED", "ACCESS", "READWRITE", "READONLY",
                     "INITIALIZEONLY", "PROPAGATION", "INHERIT", "NOINHERIT",
                     "SOURCE", "EXCLUSIVE", "COMPOSITE", "VISIBILITY",
                     "PRIVATE", "PUBLIC", "CREATEACCESSOR", "READ", "WRITE",
                     "OVERRIDDEMESSAGE", "MESSAGEHANDLER", "PRIMARY", "AROUND",
                     "BEFORE", "AFTER", "OF", "ANYINSTANCEP", "FINDINSTANCE",
                     "FINDALLINSTANCES", "DOFORINSTANCE", "DOFORALLINSTANCES",
                     "DELAYEDINSTANCES", "MAKEINSTANCE", "ACTIVEMAKEINSTANCE",
                     "Ellipsis", "LeftParen", "RightParen", "LeftBracket",
                     "RightBracket", "Less", "QUESTION", "LessEqual", "Greater",
                     "GreaterEqual", "LessGreater", "Plus", "Minus", "Mul",
                     "Power", "Connect_and", "Connection", "QUESCON", "Connect_or",
                     "Connect_not", "Div", "Int_div", "LessArrow", "Colon",
                     "Semi", "Assign", "RightAssign", "Int_number", "Float_number",
                     "INSTANCE_name", "ID", "STRING_literal", "DIGIT",
                     "Exponent", "Variable_symbol", "Global_var", "Single_field_var",
                     "Multi_field_var", "WS", "COMMENT"]

    RULE_prog = 0
    RULE_variable = 1
    RULE_expression = 2
    RULE_action = 3
    RULE_construct = 4
    RULE_numeric_expression = 5
    RULE_singlefield_expression = 6
    RULE_multifield_expression = 7
    RULE_test_expression = 8
    RULE_comparison_expression = 9
    RULE_lexeme_expression = 10
    RULE_predicate_name = 11
    RULE_connected_name = 12
    RULE_math_name = 13
    RULE_function_name = 14
    RULE_function_call = 15
    RULE_tradition_function = 16
    RULE_math_function = 17
    RULE_predicate_function = 18
    RULE_connected_function = 19
    RULE_procedural_function = 20
    RULE_if_then_else = 21
    RULE_while_do = 22
    RULE_switch_stmt = 23
    RULE_foreach = 24
    RULE_loop_for_count = 25
    RULE_return_stmt = 26
    RULE_break_stmt = 27
    RULE_case_stmt = 28
    RULE_default_stmt = 29
    RULE_range_spec = 30
    RULE_deffacts = 31
    RULE_ordered_rhs_pattern = 32
    RULE_template_rhs_pattern = 33
    RULE_rhs_slot = 34
    RULE_single_field_rhs_slot = 35
    RULE_multi_field_rhs_slot = 36
    RULE_rhs_field = 37
    RULE_rhs_pattern = 38
    RULE_deftemplate = 39
    RULE_slot_definition = 40
    RULE_single_slot = 41
    RULE_multi_slot = 42
    RULE_template_attr = 43
    RULE_default_attr = 44
    RULE_constaint_attr = 45
    RULE_type_attr = 46
    RULE_allowed_attr = 47
    RULE_range_attr = 48
    RULE_cardinality_attr = 49
    RULE_allowed_type = 50
    RULE_class_name = 51
    RULE_range_specification = 52
    RULE_cardinality_specification = 53
    RULE_defglobal = 54
    RULE_global_assignment = 55
    RULE_defrule = 56
    RULE_rule_name = 57
    RULE_declaration = 58
    RULE_rule_property = 59
    RULE_conditional_element = 60
    RULE_pattern_ce = 61
    RULE_assigned_ce = 62
    RULE_not_ce = 63
    RULE_and_ce = 64
    RULE_or_ce = 65
    RULE_logical_ce = 66
    RULE_test_ce = 67
    RULE_exists_ce = 68
    RULE_forall_ce = 69
    RULE_ordered_pattern = 70
    RULE_constaint = 71
    RULE_connected_constraint = 72
    RULE_single_constraint = 73
    RULE_term = 74
    RULE_single_field_lhs = 75
    RULE_multi_field_lhs = 76
    RULE_lhs_slot = 77
    RULE_template_pattern = 78
    RULE_attribute_constraint = 79
    RULE_object_pattern = 80
    RULE_defmodule = 81
    RULE_port_spec = 82
    RULE_port_item = 83
    RULE_port_construct = 84
    RULE_deffunction = 85
    RULE_parameter = 86
    RULE_regular_para = 87
    RULE_wildcard_para = 88
    RULE_defclass = 89
    RULE_role = 90
    RULE_pattern_match_role = 91
    RULE_slot = 92
    RULE_facet = 93
    RULE_default_facet = 94
    RULE_storage_facet = 95
    RULE_access_facet = 96
    RULE_propagation_facet = 97
    RULE_source_facet = 98
    RULE_pattern_match_facet = 99
    RULE_visibility_facet = 100
    RULE_create_accessor_facet = 101
    RULE_override_message_facet = 102
    RULE_handler_document = 103
    RULE_handler_type = 104
    RULE_defgeneric = 105
    RULE_definstances = 106
    RULE_instance_template = 107
    RULE_instance_definition = 108
    RULE_slot_override = 109
    RULE_instances = 110
    RULE_any_instancep = 111
    RULE_find_instance = 112
    RULE_do_for_instance = 113
    RULE_query = 114
    RULE_instance_set_template = 115
    RULE_instance_set_member_template = 116
    RULE_make_instance = 117
    RULE_integer_expression = 118
    RULE_float_expression = 119
    RULE_symbol_expression = 120
    RULE_string_expression = 121
    RULE_instancename_expression = 122
    RULE_constant_expression = 123
    RULE_boolen_symbol = 124

    ruleNames = ["prog", "variable", "expression", "action", "construct",
                 "numeric_expression", "singlefield_expression", "multifield_expression",
                 "test_expression", "comparison_expression", "lexeme_expression",
                 "predicate_name", "connected_name", "math_name", "function_name",
                 "function_call", "tradition_function", "math_function",
                 "predicate_function", "connected_function", "procedural_function",
                 "if_then_else", "while_do", "switch_stmt", "foreach",
                 "loop_for_count", "return_stmt", "break_stmt", "case_stmt",
                 "default_stmt", "range_spec", "deffacts", "ordered_rhs_pattern",
                 "template_rhs_pattern", "rhs_slot", "single_field_rhs_slot",
                 "multi_field_rhs_slot", "rhs_field", "rhs_pattern", "deftemplate",
                 "slot_definition", "single_slot", "multi_slot", "template_attr",
                 "default_attr", "constaint_attr", "type_attr", "allowed_attr",
                 "range_attr", "cardinality_attr", "allowed_type", "class_name",
                 "range_specification", "cardinality_specification", "defglobal",
                 "global_assignment", "defrule", "rule_name", "declaration",
                 "rule_property", "conditional_element", "pattern_ce",
                 "assigned_ce", "not_ce", "and_ce", "or_ce", "logical_ce",
                 "test_ce", "exists_ce", "forall_ce", "ordered_pattern",
                 "constaint", "connected_constraint", "single_constraint",
                 "term", "single_field_lhs", "multi_field_lhs", "lhs_slot",
                 "template_pattern", "attribute_constraint", "object_pattern",
                 "defmodule", "port_spec", "port_item", "port_construct",
                 "deffunction", "parameter", "regular_para", "wildcard_para",
                 "defclass", "role", "pattern_match_role", "slot", "facet",
                 "default_facet", "storage_facet", "access_facet", "propagation_facet",
                 "source_facet", "pattern_match_facet", "visibility_facet",
                 "create_accessor_facet", "override_message_facet", "handler_document",
                 "handler_type", "defgeneric", "definstances", "instance_template",
                 "instance_definition", "slot_override", "instances",
                 "any_instancep", "find_instance", "do_for_instance",
                 "query", "instance_set_template", "instance_set_member_template",
                 "make_instance", "integer_expression", "float_expression",
                 "symbol_expression", "string_expression", "instancename_expression",
                 "constant_expression", "boolen_symbol"]

    EOF = Token.EOF
    FLOAT = 1
    INTEGER = 2
    SYMBOL = 3
    STRING = 4
    ADDRESS = 5
    INSTANCE = 6
    EXTERNAL = 7
    FACT = 8
    CAPFLOAT = 9
    CAPINTEGER = 10
    CAPSYMBOL = 11
    CAPINSTANCE = 12
    CAPSTRING = 13
    LEXEME = 14
    NUMBER = 15
    INSTANCENAME = 16
    INSTANCEADDRESS = 17
    EXTERNALADDRESS = 18
    FACTADDRESS = 19
    WHILE = 20
    DO = 21
    IF = 22
    THEN = 23
    ELSE = 24
    RETURN = 25
    SWITCH = 26
    FOREACH = 27
    OR = 28
    EQ = 29
    NEQ = 30
    AND = 31
    TEST = 32
    NOT = 33
    MOD = 34
    DECLARE = 35
    LOGICAL = 36
    OBJECT = 37
    EXISTS = 38
    FORALL = 39
    BREAK = 40
    CASE = 41
    DEFAULT = 42
    CAPDEFAULT = 43
    LOOPFORCOUNT = 44
    TRUE = 45
    FALSE = 46
    NULL = 47
    DEFFACT = 48
    DEFTEMPLATE = 49
    DEFGLOBAL = 50
    DEFRULE = 51
    DEFFUNCTION = 52
    DEFMODULE = 53
    DEFGENERIC = 54
    DEFCLASS = 55
    DEFINSTANCES = 56
    SLOT = 57
    MULTISLOT = 58
    ALLOWEDSYMBOLS = 59
    ALLOWEDSTRINGS = 60
    ALLOWEDLEXEMES = 61
    ALLOWEDINTEGERS = 62
    ALLOWEDFLOATS = 63
    ALLOWEDNUMBERS = 64
    ALLOWEDINSTANCESNAMES = 65
    ALLOWEDCLASSES = 66
    ALLOWEDVALUES = 67
    VARIABLE = 68
    RANGE = 69
    CARDINALITY = 70
    TYPE = 71
    DERIVE = 72
    NONE = 73
    DEFAULTDYNAMIC = 74
    SALIENCE = 75
    AUTOFOCUS = 76
    ISA = 77
    ACTIVE = 78
    EXPORT = 79
    IMPORT = 80
    ALL = 81
    ROLE = 82
    CONCRETE = 83
    ABSTRACT = 84
    PATTERNMATCH = 85
    REACTIVE = 86
    NONREACTIVE = 87
    SINGLESLOT = 88
    STORAGE = 89
    LOCAL = 90
    SHARED = 91
    ACCESS = 92
    READWRITE = 93
    READONLY = 94
    INITIALIZEONLY = 95
    PROPAGATION = 96
    INHERIT = 97
    NOINHERIT = 98
    SOURCE = 99
    EXCLUSIVE = 100
    COMPOSITE = 101
    VISIBILITY = 102
    PRIVATE = 103
    PUBLIC = 104
    CREATEACCESSOR = 105
    READ = 106
    WRITE = 107
    OVERRIDDEMESSAGE = 108
    MESSAGEHANDLER = 109
    PRIMARY = 110
    AROUND = 111
    BEFORE = 112
    AFTER = 113
    OF = 114
    ANYINSTANCEP = 115
    FINDINSTANCE = 116
    FINDALLINSTANCES = 117
    DOFORINSTANCE = 118
    DOFORALLINSTANCES = 119
    DELAYEDINSTANCES = 120
    MAKEINSTANCE = 121
    ACTIVEMAKEINSTANCE = 122
    Ellipsis = 123
    LeftParen = 124
    RightParen = 125
    LeftBracket = 126
    RightBracket = 127
    Less = 128
    QUESTION = 129
    LessEqual = 130
    Greater = 131
    GreaterEqual = 132
    LessGreater = 133
    Plus = 134
    Minus = 135
    Mul = 136
    Power = 137
    Connect_and = 138
    Connection = 139
    QUESCON = 140
    Connect_or = 141
    Connect_not = 142
    Div = 143
    Int_div = 144
    LessArrow = 145
    Colon = 146
    Semi = 147
    Assign = 148
    RightAssign = 149
    Int_number = 150
    Float_number = 151
    INSTANCE_name = 152
    ID = 153
    STRING_literal = 154
    DIGIT = 155
    Exponent = 156
    Variable_symbol = 157
    Global_var = 158
    Single_field_var = 159
    Multi_field_var = 160
    WS = 161
    COMMENT = 162

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def construct(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ConstructContext)
            else:
                return self.getTypedRuleContext(clipsparser.ConstructContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_prog

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProg"):
                listener.enterProg(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProg"):
                listener.exitProg(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProg"):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)

    def prog(self):

        localctx = clipsparser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 252
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 0, self._ctx)
                if la_ == 1:
                    self.state = 250
                    self.expression()
                    pass

                elif la_ == 2:
                    self.state = 251
                    self.construct()
                    pass

                self.state = 256
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Global_var(self):
            return self.getToken(clipsparser.Global_var, 0)

        def Single_field_var(self):
            return self.getToken(clipsparser.Single_field_var, 0)

        def Multi_field_var(self):
            return self.getToken(clipsparser.Multi_field_var, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_variable

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariable"):
                listener.enterVariable(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariable"):
                listener.exitVariable(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariable"):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)

    def variable(self):

        localctx = clipsparser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_variable)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            _la = self._input.LA(1)
            if not (((((_la - 158)) & ~0x3f) == 0 and ((1 << (_la - 158)) & (
                    (1 << (clipsparser.Global_var - 158)) | (1 << (clipsparser.Single_field_var - 158)) | (
                    1 << (clipsparser.Multi_field_var - 158)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return clipsparser.RULE_expression

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class Expression_functioncallContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def function_call(self):
            return self.getTypedRuleContext(clipsparser.Function_callContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_functioncall"):
                listener.enterExpression_functioncall(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_functioncall"):
                listener.exitExpression_functioncall(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_functioncall"):
                return visitor.visitExpression_functioncall(self)
            else:
                return visitor.visitChildren(self)

    class Expression_conditionalelementContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def conditional_element(self):
            return self.getTypedRuleContext(clipsparser.Conditional_elementContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_conditionalelement"):
                listener.enterExpression_conditionalelement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_conditionalelement"):
                listener.exitExpression_conditionalelement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_conditionalelement"):
                return visitor.visitExpression_conditionalelement(self)
            else:
                return visitor.visitChildren(self)

    class Expression_variableContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variable(self):
            return self.getTypedRuleContext(clipsparser.VariableContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_variable"):
                listener.enterExpression_variable(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_variable"):
                listener.exitExpression_variable(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_variable"):
                return visitor.visitExpression_variable(self)
            else:
                return visitor.visitChildren(self)

    class Expression_mathnameContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def math_name(self):
            return self.getTypedRuleContext(clipsparser.Math_nameContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_mathname"):
                listener.enterExpression_mathname(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_mathname"):
                listener.exitExpression_mathname(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_mathname"):
                return visitor.visitExpression_mathname(self)
            else:
                return visitor.visitChildren(self)

    class Expression_predicate_nameContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate_name(self):
            return self.getTypedRuleContext(clipsparser.Predicate_nameContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_predicate_name"):
                listener.enterExpression_predicate_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_predicate_name"):
                listener.exitExpression_predicate_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_predicate_name"):
                return visitor.visitExpression_predicate_name(self)
            else:
                return visitor.visitChildren(self)

    class Expression_COMMENTContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def COMMENT(self):
            return self.getToken(clipsparser.COMMENT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_COMMENT"):
                listener.enterExpression_COMMENT(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_COMMENT"):
                listener.exitExpression_COMMENT(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_COMMENT"):
                return visitor.visitExpression_COMMENT(self)
            else:
                return visitor.visitChildren(self)

    class Expression_constantContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a clipsparser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def constant_expression(self):
            return self.getTypedRuleContext(clipsparser.Constant_expressionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_constant"):
                listener.enterExpression_constant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_constant"):
                listener.exitExpression_constant(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_constant"):
                return visitor.visitExpression_constant(self)
            else:
                return visitor.visitChildren(self)

    def expression(self):

        localctx = clipsparser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_expression)
        try:
            self.state = 266
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 2, self._ctx)
            if la_ == 1:
                localctx = clipsparser.Expression_constantContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 259
                self.constant_expression()
                pass

            elif la_ == 2:
                localctx = clipsparser.Expression_variableContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 260
                self.variable()
                pass

            elif la_ == 3:
                localctx = clipsparser.Expression_functioncallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 261
                self.function_call()
                pass

            elif la_ == 4:
                localctx = clipsparser.Expression_conditionalelementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 262
                self.conditional_element()
                pass

            elif la_ == 5:
                localctx = clipsparser.Expression_mathnameContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 263
                self.math_name()
                pass

            elif la_ == 6:
                localctx = clipsparser.Expression_predicate_nameContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 264
                self.predicate_name()
                pass

            elif la_ == 7:
                localctx = clipsparser.Expression_COMMENTContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 265
                self.match(clipsparser.COMMENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_action

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAction"):
                listener.enterAction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAction"):
                listener.exitAction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAction"):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)

    def action(self):

        localctx = clipsparser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defrule(self):
            return self.getTypedRuleContext(clipsparser.DefruleContext, 0)

        def deffacts(self):
            return self.getTypedRuleContext(clipsparser.DeffactsContext, 0)

        def defglobal(self):
            return self.getTypedRuleContext(clipsparser.DefglobalContext, 0)

        def deftemplate(self):
            return self.getTypedRuleContext(clipsparser.DeftemplateContext, 0)

        def deffunction(self):
            return self.getTypedRuleContext(clipsparser.DeffunctionContext, 0)

        def defmodule(self):
            return self.getTypedRuleContext(clipsparser.DefmoduleContext, 0)

        def defclass(self):
            return self.getTypedRuleContext(clipsparser.DefclassContext, 0)

        def defgeneric(self):
            return self.getTypedRuleContext(clipsparser.DefgenericContext, 0)

        def definstances(self):
            return self.getTypedRuleContext(clipsparser.DefinstancesContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_construct

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstruct"):
                listener.enterConstruct(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstruct"):
                listener.exitConstruct(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstruct"):
                return visitor.visitConstruct(self)
            else:
                return visitor.visitChildren(self)

    def construct(self):

        localctx = clipsparser.ConstructContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_construct)
        try:
            self.state = 279
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 3, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 270
                self.defrule()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 271
                self.deffacts()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 272
                self.defglobal()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 273
                self.deftemplate()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 274
                self.deffunction()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 275
                self.defmodule()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 276
                self.defclass()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 277
                self.defgeneric()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 278
                self.definstances()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Numeric_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer_expression(self):
            return self.getTypedRuleContext(clipsparser.Integer_expressionContext, 0)

        def float_expression(self):
            return self.getTypedRuleContext(clipsparser.Float_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_numeric_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumeric_expression"):
                listener.enterNumeric_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumeric_expression"):
                listener.exitNumeric_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumeric_expression"):
                return visitor.visitNumeric_expression(self)
            else:
                return visitor.visitChildren(self)

    def numeric_expression(self):

        localctx = clipsparser.Numeric_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_numeric_expression)
        try:
            self.state = 283
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Int_number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 281
                self.integer_expression()
                pass
            elif token in [clipsparser.Float_number]:
                self.enterOuterAlt(localctx, 2)
                self.state = 282
                self.float_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Singlefield_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_expression(self):
            return self.getTypedRuleContext(clipsparser.Constant_expressionContext, 0)

        def function_name(self):
            return self.getTypedRuleContext(clipsparser.Function_nameContext, 0)

        def predicate_name(self):
            return self.getTypedRuleContext(clipsparser.Predicate_nameContext, 0)

        def math_name(self):
            return self.getTypedRuleContext(clipsparser.Math_nameContext, 0)

        def connected_name(self):
            return self.getTypedRuleContext(clipsparser.Connected_nameContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_singlefield_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSinglefield_expression"):
                listener.enterSinglefield_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSinglefield_expression"):
                listener.exitSinglefield_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSinglefield_expression"):
                return visitor.visitSinglefield_expression(self)
            else:
                return visitor.visitChildren(self)

    def singlefield_expression(self):

        localctx = clipsparser.Singlefield_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_singlefield_expression)
        try:
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 285
                self.constant_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 286
                self.function_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 287
                self.predicate_name()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 288
                self.math_name()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 289
                self.connected_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multifield_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def singlefield_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Singlefield_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Singlefield_expressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_multifield_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultifield_expression"):
                listener.enterMultifield_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultifield_expression"):
                listener.exitMultifield_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultifield_expression"):
                return visitor.visitMultifield_expression(self)
            else:
                return visitor.visitChildren(self)

    def multifield_expression(self):

        localctx = clipsparser.Multifield_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_multifield_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(clipsparser.LeftParen)
            self.state = 296
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.OR) | (
                    1 << clipsparser.EQ) | (1 << clipsparser.NEQ) | (1 << clipsparser.AND) | (1 << clipsparser.NOT) | (
                            1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                            1 << clipsparser.NULL))) != 0) or ((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.Less - 110)) | (
                    1 << (clipsparser.LessEqual - 110)) | (1 << (clipsparser.Greater - 110)) | (
                            1 << (clipsparser.GreaterEqual - 110)) | (1 << (clipsparser.LessGreater - 110)) | (
                            1 << (clipsparser.Plus - 110)) | (1 << (clipsparser.Minus - 110)) | (
                            1 << (clipsparser.Mul - 110)) | (1 << (clipsparser.Power - 110)) | (
                            1 << (clipsparser.Div - 110)) | (1 << (clipsparser.Int_div - 110)) | (
                            1 << (clipsparser.Assign - 110)) | (1 << (clipsparser.Int_number - 110)) | (
                            1 << (clipsparser.Float_number - 110)) | (1 << (clipsparser.INSTANCE_name - 110)) | (
                            1 << (clipsparser.ID - 110)) | (1 << (clipsparser.STRING_literal - 110)))) != 0):
                self.state = 293
                self.singlefield_expression()
                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 299
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Test_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(clipsparser.VariableContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_test_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTest_expression"):
                listener.enterTest_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTest_expression"):
                listener.exitTest_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTest_expression"):
                return visitor.visitTest_expression(self)
            else:
                return visitor.visitChildren(self)

    def test_expression(self):

        localctx = clipsparser.Test_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_test_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Comparison_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Global_var(self):
            return self.getToken(clipsparser.Global_var, 0)

        def constant_expression(self):
            return self.getTypedRuleContext(clipsparser.Constant_expressionContext, 0)

        def predicate_name(self):
            return self.getTypedRuleContext(clipsparser.Predicate_nameContext, 0)

        def math_name(self):
            return self.getTypedRuleContext(clipsparser.Math_nameContext, 0)

        def connected_name(self):
            return self.getTypedRuleContext(clipsparser.Connected_nameContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_comparison_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComparison_expression"):
                listener.enterComparison_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComparison_expression"):
                listener.exitComparison_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitComparison_expression"):
                return visitor.visitComparison_expression(self)
            else:
                return visitor.visitChildren(self)

    def comparison_expression(self):

        localctx = clipsparser.Comparison_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_comparison_expression)
        try:
            self.state = 308
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Global_var]:
                self.enterOuterAlt(localctx, 1)
                self.state = 303
                self.match(clipsparser.Global_var)
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                           clipsparser.Int_number, clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                           clipsparser.STRING_literal]:
                self.enterOuterAlt(localctx, 2)
                self.state = 304
                self.constant_expression()
                pass
            elif token in [clipsparser.EQ, clipsparser.NEQ, clipsparser.Less, clipsparser.LessEqual,
                           clipsparser.Greater, clipsparser.GreaterEqual, clipsparser.LessGreater, clipsparser.Assign]:
                self.enterOuterAlt(localctx, 3)
                self.state = 305
                self.predicate_name()
                pass
            elif token in [clipsparser.FLOAT, clipsparser.INTEGER, clipsparser.MOD, clipsparser.Plus, clipsparser.Minus,
                           clipsparser.Mul, clipsparser.Power, clipsparser.Div, clipsparser.Int_div]:
                self.enterOuterAlt(localctx, 4)
                self.state = 306
                self.math_name()
                pass
            elif token in [clipsparser.OR, clipsparser.AND, clipsparser.NOT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 307
                self.connected_name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lexeme_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_lexeme_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLexeme_expression"):
                listener.enterLexeme_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLexeme_expression"):
                listener.exitLexeme_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLexeme_expression"):
                return visitor.visitLexeme_expression(self)
            else:
                return visitor.visitChildren(self)

    def lexeme_expression(self):

        localctx = clipsparser.Lexeme_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_lexeme_expression)
        try:
            self.state = 312
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.STRING_literal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 310
                self.string_expression()
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY, clipsparser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 311
                self.symbol_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Predicate_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(clipsparser.EQ, 0)

        def NEQ(self):
            return self.getToken(clipsparser.NEQ, 0)

        def Assign(self):
            return self.getToken(clipsparser.Assign, 0)

        def LessGreater(self):
            return self.getToken(clipsparser.LessGreater, 0)

        def Greater(self):
            return self.getToken(clipsparser.Greater, 0)

        def GreaterEqual(self):
            return self.getToken(clipsparser.GreaterEqual, 0)

        def Less(self):
            return self.getToken(clipsparser.Less, 0)

        def LessEqual(self):
            return self.getToken(clipsparser.LessEqual, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_predicate_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPredicate_name"):
                listener.enterPredicate_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPredicate_name"):
                listener.exitPredicate_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPredicate_name"):
                return visitor.visitPredicate_name(self)
            else:
                return visitor.visitChildren(self)

    def predicate_name(self):

        localctx = clipsparser.Predicate_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_predicate_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            _la = self._input.LA(1)
            if not (_la == clipsparser.EQ or _la == clipsparser.NEQ or ((((_la - 128)) & ~0x3f) == 0 and (
                    (1 << (_la - 128)) & ((1 << (clipsparser.Less - 128)) | (1 << (clipsparser.LessEqual - 128)) | (
                    1 << (clipsparser.Greater - 128)) | (1 << (clipsparser.GreaterEqual - 128)) | (
                                                  1 << (clipsparser.LessGreater - 128)) | (
                                                  1 << (clipsparser.Assign - 128)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Connected_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(clipsparser.AND, 0)

        def OR(self):
            return self.getToken(clipsparser.OR, 0)

        def NOT(self):
            return self.getToken(clipsparser.NOT, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_connected_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConnected_name"):
                listener.enterConnected_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConnected_name"):
                listener.exitConnected_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConnected_name"):
                return visitor.visitConnected_name(self)
            else:
                return visitor.visitChildren(self)

    def connected_name(self):

        localctx = clipsparser.Connected_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_connected_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and (
                    (1 << _la) & ((1 << clipsparser.OR) | (1 << clipsparser.AND) | (1 << clipsparser.NOT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Math_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Plus(self):
            return self.getToken(clipsparser.Plus, 0)

        def Minus(self):
            return self.getToken(clipsparser.Minus, 0)

        def Mul(self):
            return self.getToken(clipsparser.Mul, 0)

        def Div(self):
            return self.getToken(clipsparser.Div, 0)

        def Int_div(self):
            return self.getToken(clipsparser.Int_div, 0)

        def FLOAT(self):
            return self.getToken(clipsparser.FLOAT, 0)

        def INTEGER(self):
            return self.getToken(clipsparser.INTEGER, 0)

        def Power(self):
            return self.getToken(clipsparser.Power, 0)

        def MOD(self):
            return self.getToken(clipsparser.MOD, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_math_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMath_name"):
                listener.enterMath_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMath_name"):
                listener.exitMath_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMath_name"):
                return visitor.visitMath_name(self)
            else:
                return visitor.visitChildren(self)

    def math_name(self):

        localctx = clipsparser.Math_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_math_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.MOD))) != 0) or (
                            (((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & (
                            (1 << (clipsparser.Plus - 134)) | (1 << (clipsparser.Minus - 134)) | (
                            1 << (clipsparser.Mul - 134)) | (1 << (clipsparser.Power - 134)) | (
                                    1 << (clipsparser.Div - 134)) | (1 << (clipsparser.Int_div - 134)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_function_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction_name"):
                listener.enterFunction_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction_name"):
                listener.exitFunction_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction_name"):
                return visitor.visitFunction_name(self)
            else:
                return visitor.visitChildren(self)

    def function_name(self):

        localctx = clipsparser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.symbol_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_callContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tradition_function(self):
            return self.getTypedRuleContext(clipsparser.Tradition_functionContext, 0)

        def procedural_function(self):
            return self.getTypedRuleContext(clipsparser.Procedural_functionContext, 0)

        def instances(self):
            return self.getTypedRuleContext(clipsparser.InstancesContext, 0)

        def math_function(self):
            return self.getTypedRuleContext(clipsparser.Math_functionContext, 0)

        def connected_function(self):
            return self.getTypedRuleContext(clipsparser.Connected_functionContext, 0)

        def predicate_function(self):
            return self.getTypedRuleContext(clipsparser.Predicate_functionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_function_call

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction_call"):
                listener.enterFunction_call(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction_call"):
                listener.exitFunction_call(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction_call"):
                return visitor.visitFunction_call(self)
            else:
                return visitor.visitChildren(self)

    def function_call(self):

        localctx = clipsparser.Function_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_function_call)
        try:
            self.state = 328
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 9, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 322
                self.tradition_function()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 323
                self.procedural_function()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 324
                self.instances()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 325
                self.math_function()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 326
                self.connected_function()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 327
                self.predicate_function()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Tradition_functionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def function_name(self):
            return self.getTypedRuleContext(clipsparser.Function_nameContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_tradition_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTradition_function"):
                listener.enterTradition_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTradition_function"):
                listener.exitTradition_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTradition_function"):
                return visitor.visitTradition_function(self)
            else:
                return visitor.visitChildren(self)

    def tradition_function(self):

        localctx = clipsparser.Tradition_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_tradition_function)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.match(clipsparser.LeftParen)
            self.state = 331
            self.function_name()
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 332
                self.expression()
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 338
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Math_functionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def math_name(self):
            return self.getTypedRuleContext(clipsparser.Math_nameContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_math_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMath_function"):
                listener.enterMath_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMath_function"):
                listener.exitMath_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMath_function"):
                return visitor.visitMath_function(self)
            else:
                return visitor.visitChildren(self)

    def math_function(self):

        localctx = clipsparser.Math_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_math_function)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(clipsparser.LeftParen)
            self.state = 341
            self.math_name()
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 342
                self.expression()
                self.state = 347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 348
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Predicate_functionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def predicate_name(self):
            return self.getTypedRuleContext(clipsparser.Predicate_nameContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_predicate_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPredicate_function"):
                listener.enterPredicate_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPredicate_function"):
                listener.exitPredicate_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPredicate_function"):
                return visitor.visitPredicate_function(self)
            else:
                return visitor.visitChildren(self)

    def predicate_function(self):

        localctx = clipsparser.Predicate_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_predicate_function)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(clipsparser.LeftParen)
            self.state = 351
            self.predicate_name()
            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 352
                self.expression()
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 358
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Connected_functionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def connected_name(self):
            return self.getTypedRuleContext(clipsparser.Connected_nameContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_connected_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConnected_function"):
                listener.enterConnected_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConnected_function"):
                listener.exitConnected_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConnected_function"):
                return visitor.visitConnected_function(self)
            else:
                return visitor.visitChildren(self)

    def connected_function(self):

        localctx = clipsparser.Connected_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_connected_function)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(clipsparser.LeftParen)
            self.state = 361
            self.connected_name()
            self.state = 363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 362
                self.expression()
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                        1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                                (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                                (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                                1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                        1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                        1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                        1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                        1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                        1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                        1 << (clipsparser.Int_number - 110)) | (
                                        1 << (clipsparser.Float_number - 110)) | (
                                        1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                        1 << (clipsparser.STRING_literal - 110)) | (
                                        1 << (clipsparser.Global_var - 110)) | (
                                        1 << (clipsparser.Single_field_var - 110)) | (
                                        1 << (clipsparser.Multi_field_var - 110)) | (
                                        1 << (clipsparser.COMMENT - 110)))) != 0)):
                    break

            self.state = 367
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Procedural_functionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_then_else(self):
            return self.getTypedRuleContext(clipsparser.If_then_elseContext, 0)

        def while_do(self):
            return self.getTypedRuleContext(clipsparser.While_doContext, 0)

        def switch_stmt(self):
            return self.getTypedRuleContext(clipsparser.Switch_stmtContext, 0)

        def foreach(self):
            return self.getTypedRuleContext(clipsparser.ForeachContext, 0)

        def loop_for_count(self):
            return self.getTypedRuleContext(clipsparser.Loop_for_countContext, 0)

        def return_stmt(self):
            return self.getTypedRuleContext(clipsparser.Return_stmtContext, 0)

        def break_stmt(self):
            return self.getTypedRuleContext(clipsparser.Break_stmtContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_procedural_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProcedural_function"):
                listener.enterProcedural_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProcedural_function"):
                listener.exitProcedural_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProcedural_function"):
                return visitor.visitProcedural_function(self)
            else:
                return visitor.visitChildren(self)

    def procedural_function(self):

        localctx = clipsparser.Procedural_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_procedural_function)
        try:
            self.state = 376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 14, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 369
                self.if_then_else()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 370
                self.while_do()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 371
                self.switch_stmt()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 372
                self.foreach()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 373
                self.loop_for_count()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 374
                self.return_stmt()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 375
                self.break_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_then_elseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def IF(self):
            return self.getToken(clipsparser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def THEN(self):
            return self.getToken(clipsparser.THEN, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def COMMENT(self, i: int = None):
            if i is None:
                return self.getTokens(clipsparser.COMMENT)
            else:
                return self.getToken(clipsparser.COMMENT, i)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def ELSE(self):
            return self.getToken(clipsparser.ELSE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_if_then_else

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIf_then_else"):
                listener.enterIf_then_else(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIf_then_else"):
                listener.exitIf_then_else(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIf_then_else"):
                return visitor.visitIf_then_else(self)
            else:
                return visitor.visitChildren(self)

    def if_then_else(self):

        localctx = clipsparser.If_then_elseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_if_then_else)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            self.match(clipsparser.LeftParen)
            self.state = 379
            self.match(clipsparser.IF)
            self.state = 380
            self.expression()
            self.state = 384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.COMMENT:
                self.state = 381
                self.match(clipsparser.COMMENT)
                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 387
            self.match(clipsparser.THEN)
            self.state = 391
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 388
                self.action()
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.ELSE:
                self.state = 394
                self.match(clipsparser.ELSE)
                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                        1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                        (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                        (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                        1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                                1 << (clipsparser.Single_field_var - 110)) | (
                                1 << (clipsparser.Multi_field_var - 110)) | (1 << (clipsparser.COMMENT - 110)))) != 0):
                    self.state = 395
                    self.action()
                    self.state = 400
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 403
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class While_doContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def WHILE(self):
            return self.getToken(clipsparser.WHILE, 0)

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def DO(self):
            return self.getToken(clipsparser.DO, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_while_do

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhile_do"):
                listener.enterWhile_do(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhile_do"):
                listener.exitWhile_do(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhile_do"):
                return visitor.visitWhile_do(self)
            else:
                return visitor.visitChildren(self)

    def while_do(self):

        localctx = clipsparser.While_doContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_while_do)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            self.match(clipsparser.LeftParen)
            self.state = 406
            self.match(clipsparser.WHILE)
            self.state = 407
            self.expression()
            self.state = 409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.DO:
                self.state = 408
                self.match(clipsparser.DO)

            self.state = 414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 411
                self.action()
                self.state = 416
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 417
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def SWITCH(self):
            return self.getToken(clipsparser.SWITCH, 0)

        def test_expression(self):
            return self.getTypedRuleContext(clipsparser.Test_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def case_stmt(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Case_stmtContext)
            else:
                return self.getTypedRuleContext(clipsparser.Case_stmtContext, i)

        def default_stmt(self):
            return self.getTypedRuleContext(clipsparser.Default_stmtContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_switch_stmt

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_stmt"):
                listener.enterSwitch_stmt(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_stmt"):
                listener.exitSwitch_stmt(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_stmt"):
                return visitor.visitSwitch_stmt(self)
            else:
                return visitor.visitChildren(self)

    def switch_stmt(self):

        localctx = clipsparser.Switch_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_switch_stmt)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(clipsparser.LeftParen)
            self.state = 420
            self.match(clipsparser.SWITCH)
            self.state = 421
            self.test_expression()
            self.state = 425
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 21, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 422
                    self.case_stmt()
                self.state = 427
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 21, self._ctx)

            self.state = 429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.LeftParen:
                self.state = 428
                self.default_stmt()

            self.state = 431
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForeachContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def FOREACH(self):
            return self.getToken(clipsparser.FOREACH, 0)

        def variable(self):
            return self.getTypedRuleContext(clipsparser.VariableContext, 0)

        def multifield_expression(self):
            return self.getTypedRuleContext(clipsparser.Multifield_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_foreach

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForeach"):
                listener.enterForeach(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForeach"):
                listener.exitForeach(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForeach"):
                return visitor.visitForeach(self)
            else:
                return visitor.visitChildren(self)

    def foreach(self):

        localctx = clipsparser.ForeachContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_foreach)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(clipsparser.LeftParen)
            self.state = 434
            self.match(clipsparser.FOREACH)
            self.state = 435
            self.variable()
            self.state = 436
            self.multifield_expression()
            self.state = 440
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 437
                self.expression()
                self.state = 442
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 443
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Loop_for_countContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def LOOPFORCOUNT(self):
            return self.getToken(clipsparser.LOOPFORCOUNT, 0)

        def range_spec(self):
            return self.getTypedRuleContext(clipsparser.Range_specContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def DO(self):
            return self.getToken(clipsparser.DO, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_loop_for_count

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLoop_for_count"):
                listener.enterLoop_for_count(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLoop_for_count"):
                listener.exitLoop_for_count(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLoop_for_count"):
                return visitor.visitLoop_for_count(self)
            else:
                return visitor.visitChildren(self)

    def loop_for_count(self):

        localctx = clipsparser.Loop_for_countContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_loop_for_count)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.match(clipsparser.LeftParen)
            self.state = 446
            self.match(clipsparser.LOOPFORCOUNT)
            self.state = 447
            self.range_spec()
            self.state = 449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.DO:
                self.state = 448
                self.match(clipsparser.DO)

            self.state = 454
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 451
                self.action()
                self.state = 456
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 457
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Return_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def RETURN(self):
            return self.getToken(clipsparser.RETURN, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_return_stmt

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturn_stmt"):
                listener.enterReturn_stmt(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturn_stmt"):
                listener.exitReturn_stmt(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReturn_stmt"):
                return visitor.visitReturn_stmt(self)
            else:
                return visitor.visitChildren(self)

    def return_stmt(self):

        localctx = clipsparser.Return_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_return_stmt)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self.match(clipsparser.LeftParen)
            self.state = 460
            self.match(clipsparser.RETURN)
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 461
                self.expression()

            self.state = 464
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Break_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def BREAK(self):
            return self.getToken(clipsparser.BREAK, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_break_stmt

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBreak_stmt"):
                listener.enterBreak_stmt(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBreak_stmt"):
                listener.exitBreak_stmt(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBreak_stmt"):
                return visitor.visitBreak_stmt(self)
            else:
                return visitor.visitChildren(self)

    def break_stmt(self):

        localctx = clipsparser.Break_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_break_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            self.match(clipsparser.LeftParen)
            self.state = 467
            self.match(clipsparser.BREAK)
            self.state = 468
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Case_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def CASE(self):
            return self.getToken(clipsparser.CASE, 0)

        def comparison_expression(self):
            return self.getTypedRuleContext(clipsparser.Comparison_expressionContext, 0)

        def THEN(self):
            return self.getToken(clipsparser.THEN, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_case_stmt

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCase_stmt"):
                listener.enterCase_stmt(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCase_stmt"):
                listener.exitCase_stmt(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCase_stmt"):
                return visitor.visitCase_stmt(self)
            else:
                return visitor.visitChildren(self)

    def case_stmt(self):

        localctx = clipsparser.Case_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_case_stmt)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 470
            self.match(clipsparser.LeftParen)
            self.state = 471
            self.match(clipsparser.CASE)
            self.state = 472
            self.comparison_expression()
            self.state = 473
            self.match(clipsparser.THEN)
            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 474
                self.action()
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 480
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Default_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFAULT(self):
            return self.getToken(clipsparser.DEFAULT, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_default_stmt

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefault_stmt"):
                listener.enterDefault_stmt(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefault_stmt"):
                listener.exitDefault_stmt(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefault_stmt"):
                return visitor.visitDefault_stmt(self)
            else:
                return visitor.visitChildren(self)

    def default_stmt(self):

        localctx = clipsparser.Default_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_default_stmt)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            self.match(clipsparser.LeftParen)
            self.state = 483
            self.match(clipsparser.DEFAULT)
            self.state = 487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 484
                self.action()
                self.state = 489
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 490
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_specContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Integer_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Integer_expressionContext, i)

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def variable(self):
            return self.getTypedRuleContext(clipsparser.VariableContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_range_spec

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRange_spec"):
                listener.enterRange_spec(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRange_spec"):
                listener.exitRange_spec(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRange_spec"):
                return visitor.visitRange_spec(self)
            else:
                return visitor.visitChildren(self)

    def range_spec(self):

        localctx = clipsparser.Range_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_range_spec)
        try:
            self.state = 504
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 29, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 492
                self.integer_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 493
                self.match(clipsparser.LeftParen)
                self.state = 494
                self.variable()
                self.state = 495
                self.integer_expression()
                self.state = 496
                self.integer_expression()
                self.state = 497
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 499
                self.match(clipsparser.LeftParen)
                self.state = 500
                self.variable()
                self.state = 501
                self.integer_expression()
                self.state = 502
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeffactsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFFACT(self):
            return self.getToken(clipsparser.DEFFACT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def rhs_pattern(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Rhs_patternContext)
            else:
                return self.getTypedRuleContext(clipsparser.Rhs_patternContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_deffacts

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeffacts"):
                listener.enterDeffacts(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeffacts"):
                listener.exitDeffacts(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeffacts"):
                return visitor.visitDeffacts(self)
            else:
                return visitor.visitChildren(self)

    def deffacts(self):

        localctx = clipsparser.DeffactsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_deffacts)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.match(clipsparser.LeftParen)
            self.state = 507
            self.match(clipsparser.DEFFACT)
            self.state = 508
            self.symbol_expression()
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 509
                self.string_expression()

            self.state = 515
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 512
                self.rhs_pattern()
                self.state = 517
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 518
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ordered_rhs_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def rhs_field(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Rhs_fieldContext)
            else:
                return self.getTypedRuleContext(clipsparser.Rhs_fieldContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_ordered_rhs_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrdered_rhs_pattern"):
                listener.enterOrdered_rhs_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrdered_rhs_pattern"):
                listener.exitOrdered_rhs_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrdered_rhs_pattern"):
                return visitor.visitOrdered_rhs_pattern(self)
            else:
                return visitor.visitChildren(self)

    def ordered_rhs_pattern(self):

        localctx = clipsparser.Ordered_rhs_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_ordered_rhs_pattern)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.match(clipsparser.LeftParen)
            self.state = 521
            self.symbol_expression()
            self.state = 523
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 522
                self.rhs_field()
                self.state = 525
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                                (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                                (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                                1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                        1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                        1 << (clipsparser.STRING_literal - 110)) | (
                                        1 << (clipsparser.Global_var - 110)) | (
                                        1 << (clipsparser.Single_field_var - 110)) | (
                                        1 << (clipsparser.Multi_field_var - 110)))) != 0)):
                    break

            self.state = 527
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Template_rhs_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def rhs_slot(self):
            return self.getTypedRuleContext(clipsparser.Rhs_slotContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_template_rhs_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTemplate_rhs_pattern"):
                listener.enterTemplate_rhs_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTemplate_rhs_pattern"):
                listener.exitTemplate_rhs_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTemplate_rhs_pattern"):
                return visitor.visitTemplate_rhs_pattern(self)
            else:
                return visitor.visitChildren(self)

    def template_rhs_pattern(self):

        localctx = clipsparser.Template_rhs_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_template_rhs_pattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.match(clipsparser.LeftParen)
            self.state = 530
            self.symbol_expression()
            self.state = 531
            self.rhs_slot()
            self.state = 532
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rhs_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_field_rhs_slot(self):
            return self.getTypedRuleContext(clipsparser.Single_field_rhs_slotContext, 0)

        def multi_field_rhs_slot(self):
            return self.getTypedRuleContext(clipsparser.Multi_field_rhs_slotContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_rhs_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRhs_slot"):
                listener.enterRhs_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRhs_slot"):
                listener.exitRhs_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRhs_slot"):
                return visitor.visitRhs_slot(self)
            else:
                return visitor.visitChildren(self)

    def rhs_slot(self):

        localctx = clipsparser.Rhs_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_rhs_slot)
        try:
            self.state = 536
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 33, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 534
                self.single_field_rhs_slot()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 535
                self.multi_field_rhs_slot()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_field_rhs_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def rhs_field(self):
            return self.getTypedRuleContext(clipsparser.Rhs_fieldContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_single_field_rhs_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingle_field_rhs_slot"):
                listener.enterSingle_field_rhs_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingle_field_rhs_slot"):
                listener.exitSingle_field_rhs_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingle_field_rhs_slot"):
                return visitor.visitSingle_field_rhs_slot(self)
            else:
                return visitor.visitChildren(self)

    def single_field_rhs_slot(self):

        localctx = clipsparser.Single_field_rhs_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_single_field_rhs_slot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 538
            self.match(clipsparser.LeftParen)
            self.state = 539
            self.symbol_expression()
            self.state = 540
            self.rhs_field()
            self.state = 541
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_field_rhs_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def rhs_field(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Rhs_fieldContext)
            else:
                return self.getTypedRuleContext(clipsparser.Rhs_fieldContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_multi_field_rhs_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMulti_field_rhs_slot"):
                listener.enterMulti_field_rhs_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMulti_field_rhs_slot"):
                listener.exitMulti_field_rhs_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMulti_field_rhs_slot"):
                return visitor.visitMulti_field_rhs_slot(self)
            else:
                return visitor.visitChildren(self)

    def multi_field_rhs_slot(self):

        localctx = clipsparser.Multi_field_rhs_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_multi_field_rhs_slot)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(clipsparser.LeftParen)
            self.state = 544
            self.symbol_expression()
            self.state = 548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (
                            1 << (clipsparser.Multi_field_var - 110)))) != 0):
                self.state = 545
                self.rhs_field()
                self.state = 550
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 551
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rhs_fieldContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(clipsparser.VariableContext, 0)

        def constant_expression(self):
            return self.getTypedRuleContext(clipsparser.Constant_expressionContext, 0)

        def function_call(self):
            return self.getTypedRuleContext(clipsparser.Function_callContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_rhs_field

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRhs_field"):
                listener.enterRhs_field(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRhs_field"):
                listener.exitRhs_field(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRhs_field"):
                return visitor.visitRhs_field(self)
            else:
                return visitor.visitChildren(self)

    def rhs_field(self):

        localctx = clipsparser.Rhs_fieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_rhs_field)
        try:
            self.state = 556
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Global_var, clipsparser.Single_field_var, clipsparser.Multi_field_var]:
                self.enterOuterAlt(localctx, 1)
                self.state = 553
                self.variable()
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                           clipsparser.Int_number, clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                           clipsparser.STRING_literal]:
                self.enterOuterAlt(localctx, 2)
                self.state = 554
                self.constant_expression()
                pass
            elif token in [clipsparser.LeftParen]:
                self.enterOuterAlt(localctx, 3)
                self.state = 555
                self.function_call()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rhs_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ordered_rhs_pattern(self):
            return self.getTypedRuleContext(clipsparser.Ordered_rhs_patternContext, 0)

        def template_rhs_pattern(self):
            return self.getTypedRuleContext(clipsparser.Template_rhs_patternContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_rhs_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRhs_pattern"):
                listener.enterRhs_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRhs_pattern"):
                listener.exitRhs_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRhs_pattern"):
                return visitor.visitRhs_pattern(self)
            else:
                return visitor.visitChildren(self)

    def rhs_pattern(self):

        localctx = clipsparser.Rhs_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_rhs_pattern)
        try:
            self.state = 560
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 36, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 558
                self.ordered_rhs_pattern()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 559
                self.template_rhs_pattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeftemplateContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFTEMPLATE(self):
            return self.getToken(clipsparser.DEFTEMPLATE, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def slot_definition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Slot_definitionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Slot_definitionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_deftemplate

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeftemplate"):
                listener.enterDeftemplate(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeftemplate"):
                listener.exitDeftemplate(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeftemplate"):
                return visitor.visitDeftemplate(self)
            else:
                return visitor.visitChildren(self)

    def deftemplate(self):

        localctx = clipsparser.DeftemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_deftemplate)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            self.match(clipsparser.LeftParen)
            self.state = 563
            self.match(clipsparser.DEFTEMPLATE)
            self.state = 564
            self.symbol_expression()
            self.state = 566
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 565
                self.string_expression()

            self.state = 571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 568
                self.slot_definition()
                self.state = 573
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 574
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Slot_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_slot(self):
            return self.getTypedRuleContext(clipsparser.Single_slotContext, 0)

        def multi_slot(self):
            return self.getTypedRuleContext(clipsparser.Multi_slotContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_slot_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSlot_definition"):
                listener.enterSlot_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSlot_definition"):
                listener.exitSlot_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSlot_definition"):
                return visitor.visitSlot_definition(self)
            else:
                return visitor.visitChildren(self)

    def slot_definition(self):

        localctx = clipsparser.Slot_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_slot_definition)
        try:
            self.state = 578
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 39, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 576
                self.single_slot()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 577
                self.multi_slot()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def SLOT(self):
            return self.getToken(clipsparser.SLOT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def template_attr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Template_attrContext)
            else:
                return self.getTypedRuleContext(clipsparser.Template_attrContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_single_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingle_slot"):
                listener.enterSingle_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingle_slot"):
                listener.exitSingle_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingle_slot"):
                return visitor.visitSingle_slot(self)
            else:
                return visitor.visitChildren(self)

    def single_slot(self):

        localctx = clipsparser.Single_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_single_slot)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 580
            self.match(clipsparser.LeftParen)
            self.state = 581
            self.match(clipsparser.SLOT)
            self.state = 582
            self.symbol_expression()
            self.state = 586
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 583
                self.template_attr()
                self.state = 588
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 589
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def MULTISLOT(self):
            return self.getToken(clipsparser.MULTISLOT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def template_attr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Template_attrContext)
            else:
                return self.getTypedRuleContext(clipsparser.Template_attrContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_multi_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMulti_slot"):
                listener.enterMulti_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMulti_slot"):
                listener.exitMulti_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMulti_slot"):
                return visitor.visitMulti_slot(self)
            else:
                return visitor.visitChildren(self)

    def multi_slot(self):

        localctx = clipsparser.Multi_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_multi_slot)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 591
            self.match(clipsparser.LeftParen)
            self.state = 592
            self.match(clipsparser.MULTISLOT)
            self.state = 593
            self.symbol_expression()
            self.state = 597
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 594
                self.template_attr()
                self.state = 599
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 600
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Template_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def default_attr(self):
            return self.getTypedRuleContext(clipsparser.Default_attrContext, 0)

        def constaint_attr(self):
            return self.getTypedRuleContext(clipsparser.Constaint_attrContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_template_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTemplate_attr"):
                listener.enterTemplate_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTemplate_attr"):
                listener.exitTemplate_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTemplate_attr"):
                return visitor.visitTemplate_attr(self)
            else:
                return visitor.visitChildren(self)

    def template_attr(self):

        localctx = clipsparser.Template_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_template_attr)
        try:
            self.state = 604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 42, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 602
                self.default_attr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                self.constaint_attr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Default_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFAULT(self):
            return self.getToken(clipsparser.DEFAULT, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def DERIVE(self):
            return self.getToken(clipsparser.DERIVE, 0)

        def NONE(self):
            return self.getToken(clipsparser.NONE, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def DEFAULTDYNAMIC(self):
            return self.getToken(clipsparser.DEFAULTDYNAMIC, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_default_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefault_attr"):
                listener.enterDefault_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefault_attr"):
                listener.exitDefault_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefault_attr"):
                return visitor.visitDefault_attr(self)
            else:
                return visitor.visitChildren(self)

    def default_attr(self):

        localctx = clipsparser.Default_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_default_attr)
        self._la = 0  # Token type
        try:
            self.state = 628
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 46, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 606
                self.match(clipsparser.LeftParen)
                self.state = 607
                self.match(clipsparser.DEFAULT)
                self.state = 616
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.DERIVE]:
                    self.state = 608
                    self.match(clipsparser.DERIVE)
                    pass
                elif token in [clipsparser.NONE]:
                    self.state = 609
                    self.match(clipsparser.NONE)
                    pass
                elif token in [clipsparser.FLOAT, clipsparser.INTEGER, clipsparser.EQ, clipsparser.NEQ, clipsparser.MOD,
                               clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                               clipsparser.LeftParen, clipsparser.RightParen, clipsparser.Less, clipsparser.LessEqual,
                               clipsparser.Greater, clipsparser.GreaterEqual, clipsparser.LessGreater, clipsparser.Plus,
                               clipsparser.Minus, clipsparser.Mul, clipsparser.Power, clipsparser.Div,
                               clipsparser.Int_div, clipsparser.Assign, clipsparser.Int_number,
                               clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                               clipsparser.STRING_literal, clipsparser.Global_var, clipsparser.Single_field_var,
                               clipsparser.Multi_field_var, clipsparser.COMMENT]:
                    self.state = 613
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                            1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                    1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                            (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                            (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                            1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                    1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                    1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                    1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                    1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                    1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                    1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                    1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                    1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                                    1 << (clipsparser.Single_field_var - 110)) | (
                                    1 << (clipsparser.Multi_field_var - 110)) | (
                                    1 << (clipsparser.COMMENT - 110)))) != 0):
                        self.state = 610
                        self.expression()
                        self.state = 615
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 618
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 619
                self.match(clipsparser.LeftParen)
                self.state = 620
                self.match(clipsparser.DEFAULTDYNAMIC)
                self.state = 624
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                        1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                        (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                        (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                        1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                                1 << (clipsparser.Single_field_var - 110)) | (
                                1 << (clipsparser.Multi_field_var - 110)) | (1 << (clipsparser.COMMENT - 110)))) != 0):
                    self.state = 621
                    self.expression()
                    self.state = 626
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 627
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constaint_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_attr(self):
            return self.getTypedRuleContext(clipsparser.Type_attrContext, 0)

        def allowed_attr(self):
            return self.getTypedRuleContext(clipsparser.Allowed_attrContext, 0)

        def range_attr(self):
            return self.getTypedRuleContext(clipsparser.Range_attrContext, 0)

        def cardinality_attr(self):
            return self.getTypedRuleContext(clipsparser.Cardinality_attrContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_constaint_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstaint_attr"):
                listener.enterConstaint_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstaint_attr"):
                listener.exitConstaint_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstaint_attr"):
                return visitor.visitConstaint_attr(self)
            else:
                return visitor.visitChildren(self)

    def constaint_attr(self):

        localctx = clipsparser.Constaint_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_constaint_attr)
        try:
            self.state = 634
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 47, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 630
                self.type_attr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 631
                self.allowed_attr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 632
                self.range_attr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 633
                self.cardinality_attr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def TYPE(self):
            return self.getToken(clipsparser.TYPE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def VARIABLE(self):
            return self.getToken(clipsparser.VARIABLE, 0)

        def allowed_type(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Allowed_typeContext)
            else:
                return self.getTypedRuleContext(clipsparser.Allowed_typeContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_type_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_attr"):
                listener.enterType_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_attr"):
                listener.exitType_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_attr"):
                return visitor.visitType_attr(self)
            else:
                return visitor.visitChildren(self)

    def type_attr(self):

        localctx = clipsparser.Type_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_type_attr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            self.match(clipsparser.LeftParen)
            self.state = 637
            self.match(clipsparser.TYPE)
            self.state = 644
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.CAPFLOAT, clipsparser.CAPINTEGER, clipsparser.CAPSYMBOL, clipsparser.CAPINSTANCE,
                         clipsparser.CAPSTRING, clipsparser.LEXEME, clipsparser.NUMBER, clipsparser.INSTANCENAME,
                         clipsparser.INSTANCEADDRESS, clipsparser.EXTERNALADDRESS, clipsparser.FACTADDRESS]:
                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 638
                    self.allowed_type()
                    self.state = 641
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << clipsparser.CAPFLOAT) | (1 << clipsparser.CAPINTEGER) | (
                            1 << clipsparser.CAPSYMBOL) | (1 << clipsparser.CAPINSTANCE) | (
                                    1 << clipsparser.CAPSTRING) | (1 << clipsparser.LEXEME) | (
                                    1 << clipsparser.NUMBER) | (1 << clipsparser.INSTANCENAME) | (
                                    1 << clipsparser.INSTANCEADDRESS) | (1 << clipsparser.EXTERNALADDRESS) | (
                                    1 << clipsparser.FACTADDRESS))) != 0)):
                        break

                pass
            elif token in [clipsparser.VARIABLE]:
                self.state = 643
                self.match(clipsparser.VARIABLE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 646
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Allowed_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def ALLOWEDSYMBOLS(self):
            return self.getToken(clipsparser.ALLOWEDSYMBOLS, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def VARIABLE(self):
            return self.getToken(clipsparser.VARIABLE, 0)

        def symbol_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Symbol_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, i)

        def ALLOWEDSTRINGS(self):
            return self.getToken(clipsparser.ALLOWEDSTRINGS, 0)

        def string_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.String_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.String_expressionContext, i)

        def ALLOWEDLEXEMES(self):
            return self.getToken(clipsparser.ALLOWEDLEXEMES, 0)

        def lexeme_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Lexeme_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Lexeme_expressionContext, i)

        def ALLOWEDINTEGERS(self):
            return self.getToken(clipsparser.ALLOWEDINTEGERS, 0)

        def integer_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Integer_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Integer_expressionContext, i)

        def ALLOWEDFLOATS(self):
            return self.getToken(clipsparser.ALLOWEDFLOATS, 0)

        def float_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Float_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Float_expressionContext, i)

        def ALLOWEDNUMBERS(self):
            return self.getToken(clipsparser.ALLOWEDNUMBERS, 0)

        def numeric_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Numeric_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Numeric_expressionContext, i)

        def ALLOWEDINSTANCESNAMES(self):
            return self.getToken(clipsparser.ALLOWEDINSTANCESNAMES, 0)

        def instancename_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Instancename_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Instancename_expressionContext, i)

        def ALLOWEDCLASSES(self):
            return self.getToken(clipsparser.ALLOWEDCLASSES, 0)

        def class_name(self):
            return self.getTypedRuleContext(clipsparser.Class_nameContext, 0)

        def ALLOWEDVALUES(self):
            return self.getToken(clipsparser.ALLOWEDVALUES, 0)

        def constant_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Constant_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Constant_expressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_allowed_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAllowed_attr"):
                listener.enterAllowed_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAllowed_attr"):
                listener.exitAllowed_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAllowed_attr"):
                return visitor.visitAllowed_attr(self)
            else:
                return visitor.visitChildren(self)

    def allowed_attr(self):

        localctx = clipsparser.Allowed_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_allowed_attr)
        self._la = 0  # Token type
        try:
            self.state = 743
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 67, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 648
                self.match(clipsparser.LeftParen)
                self.state = 649
                self.match(clipsparser.ALLOWEDSYMBOLS)
                self.state = 656
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                             clipsparser.ID]:
                    self.state = 651
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 650
                        self.symbol_expression()
                        self.state = 653
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                                (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                                1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 655
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 658
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 659
                self.match(clipsparser.LeftParen)
                self.state = 660
                self.match(clipsparser.ALLOWEDSTRINGS)
                self.state = 667
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.STRING_literal]:
                    self.state = 662
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 661
                        self.string_expression()
                        self.state = 664
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la == clipsparser.STRING_literal):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 666
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 669
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 670
                self.match(clipsparser.LeftParen)
                self.state = 671
                self.match(clipsparser.ALLOWEDLEXEMES)
                self.state = 678
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY, clipsparser.ID,
                             clipsparser.STRING_literal]:
                    self.state = 673
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 672
                        self.lexeme_expression()
                        self.state = 675
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                                (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                                1 << clipsparser.NULL))) != 0) or ((((_la - 110)) & ~0x3f) == 0 and (
                                (1 << (_la - 110)) & (
                                (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.ID - 110)) | (
                                1 << (clipsparser.STRING_literal - 110)))) != 0)):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 677
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 680
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 681
                self.match(clipsparser.LeftParen)
                self.state = 682
                self.match(clipsparser.ALLOWEDINTEGERS)
                self.state = 689
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.Int_number]:
                    self.state = 684
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 683
                        self.integer_expression()
                        self.state = 686
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la == clipsparser.Int_number):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 688
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 691
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 692
                self.match(clipsparser.LeftParen)
                self.state = 693
                self.match(clipsparser.ALLOWEDFLOATS)
                self.state = 700
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.Float_number]:
                    self.state = 695
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 694
                        self.float_expression()
                        self.state = 697
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la == clipsparser.Float_number):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 699
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 702
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 703
                self.match(clipsparser.LeftParen)
                self.state = 704
                self.match(clipsparser.ALLOWEDNUMBERS)
                self.state = 711
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.Int_number, clipsparser.Float_number]:
                    self.state = 706
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 705
                        self.numeric_expression()
                        self.state = 708
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la == clipsparser.Int_number or _la == clipsparser.Float_number):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 710
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 713
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 714
                self.match(clipsparser.LeftParen)
                self.state = 715
                self.match(clipsparser.ALLOWEDINSTANCESNAMES)
                self.state = 722
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.INSTANCE_name]:
                    self.state = 717
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 716
                        self.instancename_expression()
                        self.state = 719
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la == clipsparser.INSTANCE_name):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 721
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 724
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 725
                self.match(clipsparser.LeftParen)
                self.state = 726
                self.match(clipsparser.ALLOWEDCLASSES)
                self.state = 729
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                             clipsparser.ID]:
                    self.state = 727
                    self.class_name()
                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 728
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 731
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 732
                self.match(clipsparser.LeftParen)
                self.state = 733
                self.match(clipsparser.ALLOWEDVALUES)
                self.state = 740
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                             clipsparser.Int_number, clipsparser.Float_number, clipsparser.INSTANCE_name,
                             clipsparser.ID, clipsparser.STRING_literal]:
                    self.state = 735
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 734
                        self.constant_expression()
                        self.state = 737
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                                (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                                1 << clipsparser.NULL))) != 0) or ((((_la - 110)) & ~0x3f) == 0 and (
                                (1 << (_la - 110)) & (
                                (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.Int_number - 110)) | (
                                1 << (clipsparser.Float_number - 110)) | (1 << (clipsparser.INSTANCE_name - 110)) | (
                                        1 << (clipsparser.ID - 110)) | (
                                        1 << (clipsparser.STRING_literal - 110)))) != 0)):
                            break

                    pass
                elif token in [clipsparser.VARIABLE]:
                    self.state = 739
                    self.match(clipsparser.VARIABLE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 742
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def RANGE(self):
            return self.getToken(clipsparser.RANGE, 0)

        def range_specification(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Range_specificationContext)
            else:
                return self.getTypedRuleContext(clipsparser.Range_specificationContext, i)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_range_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRange_attr"):
                listener.enterRange_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRange_attr"):
                listener.exitRange_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRange_attr"):
                return visitor.visitRange_attr(self)
            else:
                return visitor.visitChildren(self)

    def range_attr(self):

        localctx = clipsparser.Range_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_range_attr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 745
            self.match(clipsparser.LeftParen)
            self.state = 746
            self.match(clipsparser.RANGE)
            self.state = 747
            self.range_specification()
            self.state = 748
            self.range_specification()
            self.state = 749
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cardinality_attrContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def CARDINALITY(self):
            return self.getToken(clipsparser.CARDINALITY, 0)

        def cardinality_specification(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Cardinality_specificationContext)
            else:
                return self.getTypedRuleContext(clipsparser.Cardinality_specificationContext, i)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_cardinality_attr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCardinality_attr"):
                listener.enterCardinality_attr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCardinality_attr"):
                listener.exitCardinality_attr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCardinality_attr"):
                return visitor.visitCardinality_attr(self)
            else:
                return visitor.visitChildren(self)

    def cardinality_attr(self):

        localctx = clipsparser.Cardinality_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_cardinality_attr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.match(clipsparser.LeftParen)
            self.state = 752
            self.match(clipsparser.CARDINALITY)
            self.state = 753
            self.cardinality_specification()
            self.state = 754
            self.cardinality_specification()
            self.state = 755
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Allowed_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAPSYMBOL(self):
            return self.getToken(clipsparser.CAPSYMBOL, 0)

        def CAPSTRING(self):
            return self.getToken(clipsparser.CAPSTRING, 0)

        def LEXEME(self):
            return self.getToken(clipsparser.LEXEME, 0)

        def CAPINTEGER(self):
            return self.getToken(clipsparser.CAPINTEGER, 0)

        def CAPFLOAT(self):
            return self.getToken(clipsparser.CAPFLOAT, 0)

        def NUMBER(self):
            return self.getToken(clipsparser.NUMBER, 0)

        def INSTANCENAME(self):
            return self.getToken(clipsparser.INSTANCENAME, 0)

        def INSTANCEADDRESS(self):
            return self.getToken(clipsparser.INSTANCEADDRESS, 0)

        def CAPINSTANCE(self):
            return self.getToken(clipsparser.CAPINSTANCE, 0)

        def EXTERNALADDRESS(self):
            return self.getToken(clipsparser.EXTERNALADDRESS, 0)

        def FACTADDRESS(self):
            return self.getToken(clipsparser.FACTADDRESS, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_allowed_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAllowed_type"):
                listener.enterAllowed_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAllowed_type"):
                listener.exitAllowed_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAllowed_type"):
                return visitor.visitAllowed_type(self)
            else:
                return visitor.visitChildren(self)

    def allowed_type(self):

        localctx = clipsparser.Allowed_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_allowed_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 757
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.CAPFLOAT) | (1 << clipsparser.CAPINTEGER) | (1 << clipsparser.CAPSYMBOL) | (
                    1 << clipsparser.CAPINSTANCE) | (1 << clipsparser.CAPSTRING) | (1 << clipsparser.LEXEME) | (
                            1 << clipsparser.NUMBER) | (1 << clipsparser.INSTANCENAME) | (
                            1 << clipsparser.INSTANCEADDRESS) | (1 << clipsparser.EXTERNALADDRESS) | (
                            1 << clipsparser.FACTADDRESS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_class_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_name"):
                listener.enterClass_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_name"):
                listener.exitClass_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_name"):
                return visitor.visitClass_name(self)
            else:
                return visitor.visitChildren(self)

    def class_name(self):

        localctx = clipsparser.Class_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_class_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 759
            self.symbol_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_specificationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_expression(self):
            return self.getTypedRuleContext(clipsparser.Numeric_expressionContext, 0)

        def VARIABLE(self):
            return self.getToken(clipsparser.VARIABLE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_range_specification

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRange_specification"):
                listener.enterRange_specification(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRange_specification"):
                listener.exitRange_specification(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRange_specification"):
                return visitor.visitRange_specification(self)
            else:
                return visitor.visitChildren(self)

    def range_specification(self):

        localctx = clipsparser.Range_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_range_specification)
        try:
            self.state = 763
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Int_number, clipsparser.Float_number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 761
                self.numeric_expression()
                pass
            elif token in [clipsparser.VARIABLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 762
                self.match(clipsparser.VARIABLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cardinality_specificationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer_expression(self):
            return self.getTypedRuleContext(clipsparser.Integer_expressionContext, 0)

        def VARIABLE(self):
            return self.getToken(clipsparser.VARIABLE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_cardinality_specification

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCardinality_specification"):
                listener.enterCardinality_specification(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCardinality_specification"):
                listener.exitCardinality_specification(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCardinality_specification"):
                return visitor.visitCardinality_specification(self)
            else:
                return visitor.visitChildren(self)

    def cardinality_specification(self):

        localctx = clipsparser.Cardinality_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_cardinality_specification)
        try:
            self.state = 767
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Int_number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 765
                self.integer_expression()
                pass
            elif token in [clipsparser.VARIABLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 766
                self.match(clipsparser.VARIABLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefglobalContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFGLOBAL(self):
            return self.getToken(clipsparser.DEFGLOBAL, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def global_assignment(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Global_assignmentContext)
            else:
                return self.getTypedRuleContext(clipsparser.Global_assignmentContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_defglobal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefglobal"):
                listener.enterDefglobal(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefglobal"):
                listener.exitDefglobal(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefglobal"):
                return visitor.visitDefglobal(self)
            else:
                return visitor.visitChildren(self)

    def defglobal(self):

        localctx = clipsparser.DefglobalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_defglobal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.match(clipsparser.LeftParen)
            self.state = 770
            self.match(clipsparser.DEFGLOBAL)
            self.state = 772
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                    1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID:
                self.state = 771
                self.symbol_expression()

            self.state = 777
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.Global_var:
                self.state = 774
                self.global_assignment()
                self.state = 779
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 780
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Global_assignmentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Global_var(self):
            return self.getToken(clipsparser.Global_var, 0)

        def Assign(self):
            return self.getToken(clipsparser.Assign, 0)

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_global_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGlobal_assignment"):
                listener.enterGlobal_assignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGlobal_assignment"):
                listener.exitGlobal_assignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGlobal_assignment"):
                return visitor.visitGlobal_assignment(self)
            else:
                return visitor.visitChildren(self)

    def global_assignment(self):

        localctx = clipsparser.Global_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_global_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            self.match(clipsparser.Global_var)
            self.state = 783
            self.match(clipsparser.Assign)
            self.state = 784
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefruleContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFRULE(self):
            return self.getToken(clipsparser.DEFRULE, 0)

        def rule_name(self):
            return self.getTypedRuleContext(clipsparser.Rule_nameContext, 0)

        def RightAssign(self):
            return self.getToken(clipsparser.RightAssign, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def declaration(self):
            return self.getTypedRuleContext(clipsparser.DeclarationContext, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_defrule

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefrule"):
                listener.enterDefrule(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefrule"):
                listener.exitDefrule(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefrule"):
                return visitor.visitDefrule(self)
            else:
                return visitor.visitChildren(self)

    def defrule(self):

        localctx = clipsparser.DefruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_defrule)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 786
            self.match(clipsparser.LeftParen)
            self.state = 787
            self.match(clipsparser.DEFRULE)
            self.state = 788
            self.rule_name()
            self.state = 790
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 789
                self.string_expression()

            self.state = 793
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 73, self._ctx)
            if la_ == 1:
                self.state = 792
                self.declaration()

            self.state = 798
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen or _la == clipsparser.Single_field_var:
                self.state = 795
                self.conditional_element()
                self.state = 800
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 801
            self.match(clipsparser.RightAssign)
            self.state = 805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 802
                self.action()
                self.state = 807
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 808
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rule_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_rule_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRule_name"):
                listener.enterRule_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRule_name"):
                listener.exitRule_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRule_name"):
                return visitor.visitRule_name(self)
            else:
                return visitor.visitChildren(self)

    def rule_name(self):

        localctx = clipsparser.Rule_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rule_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 810
            self.symbol_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DECLARE(self):
            return self.getToken(clipsparser.DECLARE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def rule_property(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Rule_propertyContext)
            else:
                return self.getTypedRuleContext(clipsparser.Rule_propertyContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeclaration"):
                listener.enterDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeclaration"):
                listener.exitDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeclaration"):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def declaration(self):

        localctx = clipsparser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.match(clipsparser.LeftParen)
            self.state = 813
            self.match(clipsparser.DECLARE)
            self.state = 815
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 814
                self.rule_property()
                self.state = 817
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen):
                    break

            self.state = 819
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rule_propertyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def SALIENCE(self):
            return self.getToken(clipsparser.SALIENCE, 0)

        def integer_expression(self):
            return self.getTypedRuleContext(clipsparser.Integer_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def AUTOFOCUS(self):
            return self.getToken(clipsparser.AUTOFOCUS, 0)

        def boolen_symbol(self):
            return self.getTypedRuleContext(clipsparser.Boolen_symbolContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_rule_property

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRule_property"):
                listener.enterRule_property(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRule_property"):
                listener.exitRule_property(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRule_property"):
                return visitor.visitRule_property(self)
            else:
                return visitor.visitChildren(self)

    def rule_property(self):

        localctx = clipsparser.Rule_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_rule_property)
        try:
            self.state = 831
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 77, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 821
                self.match(clipsparser.LeftParen)
                self.state = 822
                self.match(clipsparser.SALIENCE)
                self.state = 823
                self.integer_expression()
                self.state = 824
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 826
                self.match(clipsparser.LeftParen)
                self.state = 827
                self.match(clipsparser.AUTOFOCUS)
                self.state = 828
                self.boolen_symbol()
                self.state = 829
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_elementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern_ce(self):
            return self.getTypedRuleContext(clipsparser.Pattern_ceContext, 0)

        def assigned_ce(self):
            return self.getTypedRuleContext(clipsparser.Assigned_ceContext, 0)

        def not_ce(self):
            return self.getTypedRuleContext(clipsparser.Not_ceContext, 0)

        def and_ce(self):
            return self.getTypedRuleContext(clipsparser.And_ceContext, 0)

        def or_ce(self):
            return self.getTypedRuleContext(clipsparser.Or_ceContext, 0)

        def logical_ce(self):
            return self.getTypedRuleContext(clipsparser.Logical_ceContext, 0)

        def test_ce(self):
            return self.getTypedRuleContext(clipsparser.Test_ceContext, 0)

        def exists_ce(self):
            return self.getTypedRuleContext(clipsparser.Exists_ceContext, 0)

        def forall_ce(self):
            return self.getTypedRuleContext(clipsparser.Forall_ceContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_conditional_element

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditional_element"):
                listener.enterConditional_element(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditional_element"):
                listener.exitConditional_element(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditional_element"):
                return visitor.visitConditional_element(self)
            else:
                return visitor.visitChildren(self)

    def conditional_element(self):

        localctx = clipsparser.Conditional_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_conditional_element)
        try:
            self.state = 842
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 78, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 833
                self.pattern_ce()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 834
                self.assigned_ce()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 835
                self.not_ce()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 836
                self.and_ce()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 837
                self.or_ce()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 838
                self.logical_ce()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 839
                self.test_ce()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 840
                self.exists_ce()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 841
                self.forall_ce()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pattern_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ordered_pattern(self):
            return self.getTypedRuleContext(clipsparser.Ordered_patternContext, 0)

        def template_pattern(self):
            return self.getTypedRuleContext(clipsparser.Template_patternContext, 0)

        def object_pattern(self):
            return self.getTypedRuleContext(clipsparser.Object_patternContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_pattern_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPattern_ce"):
                listener.enterPattern_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPattern_ce"):
                listener.exitPattern_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPattern_ce"):
                return visitor.visitPattern_ce(self)
            else:
                return visitor.visitChildren(self)

    def pattern_ce(self):

        localctx = clipsparser.Pattern_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_pattern_ce)
        try:
            self.state = 847
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 79, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 844
                self.ordered_pattern()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 845
                self.template_pattern()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 846
                self.object_pattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assigned_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Single_field_var(self):
            return self.getToken(clipsparser.Single_field_var, 0)

        def LessArrow(self):
            return self.getToken(clipsparser.LessArrow, 0)

        def pattern_ce(self):
            return self.getTypedRuleContext(clipsparser.Pattern_ceContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_assigned_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssigned_ce"):
                listener.enterAssigned_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssigned_ce"):
                listener.exitAssigned_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssigned_ce"):
                return visitor.visitAssigned_ce(self)
            else:
                return visitor.visitChildren(self)

    def assigned_ce(self):

        localctx = clipsparser.Assigned_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_assigned_ce)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 849
            self.match(clipsparser.Single_field_var)
            self.state = 850
            self.match(clipsparser.LessArrow)
            self.state = 851
            self.pattern_ce()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Not_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def NOT(self):
            return self.getToken(clipsparser.NOT, 0)

        def conditional_element(self):
            return self.getTypedRuleContext(clipsparser.Conditional_elementContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_not_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNot_ce"):
                listener.enterNot_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNot_ce"):
                listener.exitNot_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNot_ce"):
                return visitor.visitNot_ce(self)
            else:
                return visitor.visitChildren(self)

    def not_ce(self):

        localctx = clipsparser.Not_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_not_ce)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            self.match(clipsparser.LeftParen)
            self.state = 854
            self.match(clipsparser.NOT)
            self.state = 855
            self.conditional_element()
            self.state = 856
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def AND(self):
            return self.getToken(clipsparser.AND, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_and_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnd_ce"):
                listener.enterAnd_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnd_ce"):
                listener.exitAnd_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnd_ce"):
                return visitor.visitAnd_ce(self)
            else:
                return visitor.visitChildren(self)

    def and_ce(self):

        localctx = clipsparser.And_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_and_ce)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 858
            self.match(clipsparser.LeftParen)
            self.state = 859
            self.match(clipsparser.AND)
            self.state = 861
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 860
                self.conditional_element()
                self.state = 863
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen or _la == clipsparser.Single_field_var):
                    break

            self.state = 865
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Or_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def OR(self):
            return self.getToken(clipsparser.OR, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_or_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOr_ce"):
                listener.enterOr_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOr_ce"):
                listener.exitOr_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOr_ce"):
                return visitor.visitOr_ce(self)
            else:
                return visitor.visitChildren(self)

    def or_ce(self):

        localctx = clipsparser.Or_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_or_ce)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            self.match(clipsparser.LeftParen)
            self.state = 868
            self.match(clipsparser.OR)
            self.state = 870
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 869
                self.conditional_element()
                self.state = 872
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen or _la == clipsparser.Single_field_var):
                    break

            self.state = 874
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Logical_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def LOGICAL(self):
            return self.getToken(clipsparser.LOGICAL, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_logical_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLogical_ce"):
                listener.enterLogical_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLogical_ce"):
                listener.exitLogical_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLogical_ce"):
                return visitor.visitLogical_ce(self)
            else:
                return visitor.visitChildren(self)

    def logical_ce(self):

        localctx = clipsparser.Logical_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_logical_ce)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 876
            self.match(clipsparser.LeftParen)
            self.state = 877
            self.match(clipsparser.LOGICAL)
            self.state = 879
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 878
                self.conditional_element()
                self.state = 881
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen or _la == clipsparser.Single_field_var):
                    break

            self.state = 883
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Test_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def TEST(self):
            return self.getToken(clipsparser.TEST, 0)

        def function_call(self):
            return self.getTypedRuleContext(clipsparser.Function_callContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_test_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTest_ce"):
                listener.enterTest_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTest_ce"):
                listener.exitTest_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTest_ce"):
                return visitor.visitTest_ce(self)
            else:
                return visitor.visitChildren(self)

    def test_ce(self):

        localctx = clipsparser.Test_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_test_ce)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            self.match(clipsparser.LeftParen)
            self.state = 886
            self.match(clipsparser.TEST)
            self.state = 887
            self.function_call()
            self.state = 888
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Exists_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def EXISTS(self):
            return self.getToken(clipsparser.EXISTS, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_exists_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExists_ce"):
                listener.enterExists_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExists_ce"):
                listener.exitExists_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExists_ce"):
                return visitor.visitExists_ce(self)
            else:
                return visitor.visitChildren(self)

    def exists_ce(self):

        localctx = clipsparser.Exists_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_exists_ce)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 890
            self.match(clipsparser.LeftParen)
            self.state = 891
            self.match(clipsparser.EXISTS)
            self.state = 893
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 892
                self.conditional_element()
                self.state = 895
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen or _la == clipsparser.Single_field_var):
                    break

            self.state = 897
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Forall_ceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def FORALL(self):
            return self.getToken(clipsparser.FORALL, 0)

        def conditional_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Conditional_elementContext)
            else:
                return self.getTypedRuleContext(clipsparser.Conditional_elementContext, i)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_forall_ce

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForall_ce"):
                listener.enterForall_ce(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForall_ce"):
                listener.exitForall_ce(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForall_ce"):
                return visitor.visitForall_ce(self)
            else:
                return visitor.visitChildren(self)

    def forall_ce(self):

        localctx = clipsparser.Forall_ceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_forall_ce)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 899
            self.match(clipsparser.LeftParen)
            self.state = 900
            self.match(clipsparser.FORALL)
            self.state = 901
            self.conditional_element()
            self.state = 903
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 902
                self.conditional_element()
                self.state = 905
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen or _la == clipsparser.Single_field_var):
                    break

            self.state = 907
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ordered_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def constaint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ConstaintContext)
            else:
                return self.getTypedRuleContext(clipsparser.ConstaintContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_ordered_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrdered_pattern"):
                listener.enterOrdered_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrdered_pattern"):
                listener.exitOrdered_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrdered_pattern"):
                return visitor.visitOrdered_pattern(self)
            else:
                return visitor.visitChildren(self)

    def ordered_pattern(self):

        localctx = clipsparser.Ordered_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_ordered_pattern)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 909
            self.match(clipsparser.LeftParen)
            self.state = 910
            self.symbol_expression()
            self.state = 914
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.QUESTION - 110)) | (
                    1 << (clipsparser.QUESCON - 110)) | (1 << (clipsparser.Connect_not - 110)) | (
                            1 << (clipsparser.Colon - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Single_field_var - 110)) | (
                            1 << (clipsparser.Multi_field_var - 110)))) != 0):
                self.state = 911
                self.constaint()
                self.state = 916
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 917
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstaintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUESTION(self):
            return self.getToken(clipsparser.QUESTION, 0)

        def QUESCON(self):
            return self.getToken(clipsparser.QUESCON, 0)

        def connected_constraint(self):
            return self.getTypedRuleContext(clipsparser.Connected_constraintContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_constaint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstaint"):
                listener.enterConstaint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstaint"):
                listener.exitConstaint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstaint"):
                return visitor.visitConstaint(self)
            else:
                return visitor.visitChildren(self)

    def constaint(self):

        localctx = clipsparser.ConstaintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_constaint)
        try:
            self.state = 922
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.QUESTION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 919
                self.match(clipsparser.QUESTION)
                pass
            elif token in [clipsparser.QUESCON]:
                self.enterOuterAlt(localctx, 2)
                self.state = 920
                self.match(clipsparser.QUESCON)
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                           clipsparser.Connect_not, clipsparser.Colon, clipsparser.Assign, clipsparser.Int_number,
                           clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                           clipsparser.STRING_literal, clipsparser.Single_field_var, clipsparser.Multi_field_var]:
                self.enterOuterAlt(localctx, 3)
                self.state = 921
                self.connected_constraint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Connected_constraintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_constraint(self):
            return self.getTypedRuleContext(clipsparser.Single_constraintContext, 0)

        def Connect_and(self):
            return self.getToken(clipsparser.Connect_and, 0)

        def connected_constraint(self):
            return self.getTypedRuleContext(clipsparser.Connected_constraintContext, 0)

        def Connect_or(self):
            return self.getToken(clipsparser.Connect_or, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_connected_constraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConnected_constraint"):
                listener.enterConnected_constraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConnected_constraint"):
                listener.exitConnected_constraint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConnected_constraint"):
                return visitor.visitConnected_constraint(self)
            else:
                return visitor.visitChildren(self)

    def connected_constraint(self):

        localctx = clipsparser.Connected_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_connected_constraint)
        try:
            self.state = 933
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 87, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 924
                self.single_constraint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 925
                self.single_constraint()
                self.state = 926
                self.match(clipsparser.Connect_and)
                self.state = 927
                self.connected_constraint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 929
                self.single_constraint()
                self.state = 930
                self.match(clipsparser.Connect_or)
                self.state = 931
                self.connected_constraint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_constraintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(clipsparser.TermContext, 0)

        def Connect_not(self):
            return self.getToken(clipsparser.Connect_not, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_single_constraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingle_constraint"):
                listener.enterSingle_constraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingle_constraint"):
                listener.exitSingle_constraint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingle_constraint"):
                return visitor.visitSingle_constraint(self)
            else:
                return visitor.visitChildren(self)

    def single_constraint(self):

        localctx = clipsparser.Single_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_single_constraint)
        try:
            self.state = 938
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY, clipsparser.Colon,
                         clipsparser.Assign, clipsparser.Int_number, clipsparser.Float_number,
                         clipsparser.INSTANCE_name, clipsparser.ID, clipsparser.STRING_literal,
                         clipsparser.Single_field_var, clipsparser.Multi_field_var]:
                self.enterOuterAlt(localctx, 1)
                self.state = 935
                self.term()
                pass
            elif token in [clipsparser.Connect_not]:
                self.enterOuterAlt(localctx, 2)
                self.state = 936
                self.match(clipsparser.Connect_not)
                self.state = 937
                self.term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_expression(self):
            return self.getTypedRuleContext(clipsparser.Constant_expressionContext, 0)

        def Single_field_var(self):
            return self.getToken(clipsparser.Single_field_var, 0)

        def Multi_field_var(self):
            return self.getToken(clipsparser.Multi_field_var, 0)

        def Colon(self):
            return self.getToken(clipsparser.Colon, 0)

        def function_call(self):
            return self.getTypedRuleContext(clipsparser.Function_callContext, 0)

        def Assign(self):
            return self.getToken(clipsparser.Assign, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_term

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTerm"):
                listener.enterTerm(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTerm"):
                listener.exitTerm(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTerm"):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)

    def term(self):

        localctx = clipsparser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_term)
        try:
            self.state = 947
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                         clipsparser.Int_number, clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                         clipsparser.STRING_literal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 940
                self.constant_expression()
                pass
            elif token in [clipsparser.Single_field_var]:
                self.enterOuterAlt(localctx, 2)
                self.state = 941
                self.match(clipsparser.Single_field_var)
                pass
            elif token in [clipsparser.Multi_field_var]:
                self.enterOuterAlt(localctx, 3)
                self.state = 942
                self.match(clipsparser.Multi_field_var)
                pass
            elif token in [clipsparser.Colon]:
                self.enterOuterAlt(localctx, 4)
                self.state = 943
                self.match(clipsparser.Colon)
                self.state = 944
                self.function_call()
                pass
            elif token in [clipsparser.Assign]:
                self.enterOuterAlt(localctx, 5)
                self.state = 945
                self.match(clipsparser.Assign)
                self.state = 946
                self.function_call()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_field_lhsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def constaint(self):
            return self.getTypedRuleContext(clipsparser.ConstaintContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_single_field_lhs

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingle_field_lhs"):
                listener.enterSingle_field_lhs(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingle_field_lhs"):
                listener.exitSingle_field_lhs(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingle_field_lhs"):
                return visitor.visitSingle_field_lhs(self)
            else:
                return visitor.visitChildren(self)

    def single_field_lhs(self):

        localctx = clipsparser.Single_field_lhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_single_field_lhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 949
            self.match(clipsparser.LeftParen)
            self.state = 950
            self.symbol_expression()
            self.state = 951
            self.constaint()
            self.state = 952
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_field_lhsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def constaint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ConstaintContext)
            else:
                return self.getTypedRuleContext(clipsparser.ConstaintContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_multi_field_lhs

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMulti_field_lhs"):
                listener.enterMulti_field_lhs(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMulti_field_lhs"):
                listener.exitMulti_field_lhs(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMulti_field_lhs"):
                return visitor.visitMulti_field_lhs(self)
            else:
                return visitor.visitChildren(self)

    def multi_field_lhs(self):

        localctx = clipsparser.Multi_field_lhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_multi_field_lhs)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.match(clipsparser.LeftParen)
            self.state = 955
            self.symbol_expression()
            self.state = 959
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.QUESTION - 110)) | (
                    1 << (clipsparser.QUESCON - 110)) | (1 << (clipsparser.Connect_not - 110)) | (
                            1 << (clipsparser.Colon - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Single_field_var - 110)) | (
                            1 << (clipsparser.Multi_field_var - 110)))) != 0):
                self.state = 956
                self.constaint()
                self.state = 961
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 962
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lhs_slotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_field_lhs(self):
            return self.getTypedRuleContext(clipsparser.Single_field_lhsContext, 0)

        def multi_field_lhs(self):
            return self.getTypedRuleContext(clipsparser.Multi_field_lhsContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_lhs_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLhs_slot"):
                listener.enterLhs_slot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLhs_slot"):
                listener.exitLhs_slot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLhs_slot"):
                return visitor.visitLhs_slot(self)
            else:
                return visitor.visitChildren(self)

    def lhs_slot(self):

        localctx = clipsparser.Lhs_slotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_lhs_slot)
        try:
            self.state = 966
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 91, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 964
                self.single_field_lhs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 965
                self.multi_field_lhs()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Template_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def lhs_slot(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Lhs_slotContext)
            else:
                return self.getTypedRuleContext(clipsparser.Lhs_slotContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_template_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTemplate_pattern"):
                listener.enterTemplate_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTemplate_pattern"):
                listener.exitTemplate_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTemplate_pattern"):
                return visitor.visitTemplate_pattern(self)
            else:
                return visitor.visitChildren(self)

    def template_pattern(self):

        localctx = clipsparser.Template_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_template_pattern)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self.match(clipsparser.LeftParen)
            self.state = 969
            self.symbol_expression()
            self.state = 973
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 970
                self.lhs_slot()
                self.state = 975
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 976
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Attribute_constraintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def ISA(self):
            return self.getToken(clipsparser.ISA, 0)

        def constaint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ConstaintContext)
            else:
                return self.getTypedRuleContext(clipsparser.ConstaintContext, i)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_attribute_constraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute_constraint"):
                listener.enterAttribute_constraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute_constraint"):
                listener.exitAttribute_constraint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute_constraint"):
                return visitor.visitAttribute_constraint(self)
            else:
                return visitor.visitChildren(self)

    def attribute_constraint(self):

        localctx = clipsparser.Attribute_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_attribute_constraint)
        self._la = 0  # Token type
        try:
            self.state = 993
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 94, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 978
                self.match(clipsparser.LeftParen)
                self.state = 979
                self.match(clipsparser.ISA)
                self.state = 980
                self.constaint()
                self.state = 981
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 983
                self.match(clipsparser.LeftParen)
                self.state = 984
                self.symbol_expression()
                self.state = 988
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                        (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                        (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.QUESTION - 110)) | (
                        1 << (clipsparser.QUESCON - 110)) | (1 << (clipsparser.Connect_not - 110)) | (
                                1 << (clipsparser.Colon - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                1 << (clipsparser.STRING_literal - 110)) | (
                                1 << (clipsparser.Single_field_var - 110)) | (
                                1 << (clipsparser.Multi_field_var - 110)))) != 0):
                    self.state = 985
                    self.constaint()
                    self.state = 990
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 991
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_patternContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def OBJECT(self):
            return self.getToken(clipsparser.OBJECT, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def attribute_constraint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Attribute_constraintContext)
            else:
                return self.getTypedRuleContext(clipsparser.Attribute_constraintContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_object_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterObject_pattern"):
                listener.enterObject_pattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitObject_pattern"):
                listener.exitObject_pattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitObject_pattern"):
                return visitor.visitObject_pattern(self)
            else:
                return visitor.visitChildren(self)

    def object_pattern(self):

        localctx = clipsparser.Object_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_object_pattern)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 995
            self.match(clipsparser.LeftParen)
            self.state = 996
            self.match(clipsparser.OBJECT)
            self.state = 1000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 997
                self.attribute_constraint()
                self.state = 1002
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1003
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefmoduleContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFMODULE(self):
            return self.getToken(clipsparser.DEFMODULE, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def port_spec(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Port_specContext)
            else:
                return self.getTypedRuleContext(clipsparser.Port_specContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_defmodule

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefmodule"):
                listener.enterDefmodule(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefmodule"):
                listener.exitDefmodule(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefmodule"):
                return visitor.visitDefmodule(self)
            else:
                return visitor.visitChildren(self)

    def defmodule(self):

        localctx = clipsparser.DefmoduleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_defmodule)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            self.match(clipsparser.LeftParen)
            self.state = 1006
            self.match(clipsparser.DEFMODULE)
            self.state = 1007
            self.symbol_expression()
            self.state = 1009
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 1008
                self.string_expression()

            self.state = 1014
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 1011
                self.port_spec()
                self.state = 1016
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1017
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Port_specContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def EXPORT(self):
            return self.getToken(clipsparser.EXPORT, 0)

        def port_item(self):
            return self.getTypedRuleContext(clipsparser.Port_itemContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def IMPORT(self):
            return self.getToken(clipsparser.IMPORT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_port_spec

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPort_spec"):
                listener.enterPort_spec(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPort_spec"):
                listener.exitPort_spec(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPort_spec"):
                return visitor.visitPort_spec(self)
            else:
                return visitor.visitChildren(self)

    def port_spec(self):

        localctx = clipsparser.Port_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_port_spec)
        try:
            self.state = 1030
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 98, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1019
                self.match(clipsparser.LeftParen)
                self.state = 1020
                self.match(clipsparser.EXPORT)
                self.state = 1021
                self.port_item()
                self.state = 1022
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1024
                self.match(clipsparser.LeftParen)
                self.state = 1025
                self.match(clipsparser.IMPORT)
                self.state = 1026
                self.symbol_expression()
                self.state = 1027
                self.port_item()
                self.state = 1028
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Port_itemContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(clipsparser.ALL, 0)

        def NONE(self):
            return self.getToken(clipsparser.NONE, 0)

        def port_construct(self):
            return self.getTypedRuleContext(clipsparser.Port_constructContext, 0)

        def symbol_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Symbol_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_port_item

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPort_item"):
                listener.enterPort_item(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPort_item"):
                listener.exitPort_item(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPort_item"):
                return visitor.visitPort_item(self)
            else:
                return visitor.visitChildren(self)

    def port_item(self):

        localctx = clipsparser.Port_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_port_item)
        self._la = 0  # Token type
        try:
            self.state = 1046
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 100, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1032
                self.match(clipsparser.ALL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1033
                self.match(clipsparser.NONE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1034
                self.port_construct()
                self.state = 1035
                self.match(clipsparser.ALL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1037
                self.port_construct()
                self.state = 1038
                self.match(clipsparser.NONE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1040
                self.port_construct()
                self.state = 1042
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1041
                    self.symbol_expression()
                    self.state = 1044
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                            1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Port_constructContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFTEMPLATE(self):
            return self.getToken(clipsparser.DEFTEMPLATE, 0)

        def DEFCLASS(self):
            return self.getToken(clipsparser.DEFCLASS, 0)

        def DEFGLOBAL(self):
            return self.getToken(clipsparser.DEFGLOBAL, 0)

        def DEFFUNCTION(self):
            return self.getToken(clipsparser.DEFFUNCTION, 0)

        def DEFGENERIC(self):
            return self.getToken(clipsparser.DEFGENERIC, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_port_construct

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPort_construct"):
                listener.enterPort_construct(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPort_construct"):
                listener.exitPort_construct(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPort_construct"):
                return visitor.visitPort_construct(self)
            else:
                return visitor.visitChildren(self)

    def port_construct(self):

        localctx = clipsparser.Port_constructContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_port_construct)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1048
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.DEFTEMPLATE) | (1 << clipsparser.DEFGLOBAL) | (1 << clipsparser.DEFFUNCTION) | (
                    1 << clipsparser.DEFGENERIC) | (1 << clipsparser.DEFCLASS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeffunctionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFFUNCTION(self):
            return self.getToken(clipsparser.DEFFUNCTION, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def parameter(self):
            return self.getTypedRuleContext(clipsparser.ParameterContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_deffunction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeffunction"):
                listener.enterDeffunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeffunction"):
                listener.exitDeffunction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeffunction"):
                return visitor.visitDeffunction(self)
            else:
                return visitor.visitChildren(self)

    def deffunction(self):

        localctx = clipsparser.DeffunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_deffunction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1050
            self.match(clipsparser.LeftParen)
            self.state = 1051
            self.match(clipsparser.DEFFUNCTION)
            self.state = 1052
            self.symbol_expression()
            self.state = 1054
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 1053
                self.string_expression()

            self.state = 1056
            self.parameter()
            self.state = 1060
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 1057
                self.action()
                self.state = 1062
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1063
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def regular_para(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Regular_paraContext)
            else:
                return self.getTypedRuleContext(clipsparser.Regular_paraContext, i)

        def wildcard_para(self):
            return self.getTypedRuleContext(clipsparser.Wildcard_paraContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_parameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameter"):
                listener.enterParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameter"):
                listener.exitParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParameter"):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)

    def parameter(self):

        localctx = clipsparser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_parameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1065
            self.match(clipsparser.LeftParen)
            self.state = 1069
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.Single_field_var:
                self.state = 1066
                self.regular_para()
                self.state = 1071
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1073
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.Multi_field_var:
                self.state = 1072
                self.wildcard_para()

            self.state = 1075
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Regular_paraContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Single_field_var(self):
            return self.getToken(clipsparser.Single_field_var, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_regular_para

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRegular_para"):
                listener.enterRegular_para(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRegular_para"):
                listener.exitRegular_para(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRegular_para"):
                return visitor.visitRegular_para(self)
            else:
                return visitor.visitChildren(self)

    def regular_para(self):

        localctx = clipsparser.Regular_paraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_regular_para)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1077
            self.match(clipsparser.Single_field_var)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Wildcard_paraContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Multi_field_var(self):
            return self.getToken(clipsparser.Multi_field_var, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_wildcard_para

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWildcard_para"):
                listener.enterWildcard_para(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWildcard_para"):
                listener.exitWildcard_para(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWildcard_para"):
                return visitor.visitWildcard_para(self)
            else:
                return visitor.visitChildren(self)

    def wildcard_para(self):

        localctx = clipsparser.Wildcard_paraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_wildcard_para)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1079
            self.match(clipsparser.Multi_field_var)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefclassContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self, i: int = None):
            if i is None:
                return self.getTokens(clipsparser.LeftParen)
            else:
                return self.getToken(clipsparser.LeftParen, i)

        def DEFCLASS(self):
            return self.getToken(clipsparser.DEFCLASS, 0)

        def symbol_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Symbol_expressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, i)

        def ISA(self):
            return self.getToken(clipsparser.ISA, 0)

        def RightParen(self, i: int = None):
            if i is None:
                return self.getTokens(clipsparser.RightParen)
            else:
                return self.getToken(clipsparser.RightParen, i)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def role(self):
            return self.getTypedRuleContext(clipsparser.RoleContext, 0)

        def pattern_match_role(self):
            return self.getTypedRuleContext(clipsparser.Pattern_match_roleContext, 0)

        def slot(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.SlotContext)
            else:
                return self.getTypedRuleContext(clipsparser.SlotContext, i)

        def handler_document(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Handler_documentContext)
            else:
                return self.getTypedRuleContext(clipsparser.Handler_documentContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_defclass

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefclass"):
                listener.enterDefclass(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefclass"):
                listener.exitDefclass(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefclass"):
                return visitor.visitDefclass(self)
            else:
                return visitor.visitChildren(self)

    def defclass(self):

        localctx = clipsparser.DefclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_defclass)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1081
            self.match(clipsparser.LeftParen)
            self.state = 1082
            self.match(clipsparser.DEFCLASS)
            self.state = 1083
            self.symbol_expression()
            self.state = 1085
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 1084
                self.string_expression()

            self.state = 1087
            self.match(clipsparser.LeftParen)
            self.state = 1088
            self.match(clipsparser.ISA)
            self.state = 1090
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1089
                self.symbol_expression()
                self.state = 1092
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                        1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID):
                    break

            self.state = 1094
            self.match(clipsparser.RightParen)
            self.state = 1096
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 107, self._ctx)
            if la_ == 1:
                self.state = 1095
                self.role()

            self.state = 1099
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 108, self._ctx)
            if la_ == 1:
                self.state = 1098
                self.pattern_match_role()

            self.state = 1104
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 109, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1101
                    self.slot()
                self.state = 1106
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 109, self._ctx)

            self.state = 1110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 1107
                self.handler_document()
                self.state = 1112
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1113
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def ROLE(self):
            return self.getToken(clipsparser.ROLE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def CONCRETE(self):
            return self.getToken(clipsparser.CONCRETE, 0)

        def ABSTRACT(self):
            return self.getToken(clipsparser.ABSTRACT, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_role

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRole"):
                listener.enterRole(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRole"):
                listener.exitRole(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRole"):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)

    def role(self):

        localctx = clipsparser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_role)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1115
            self.match(clipsparser.LeftParen)
            self.state = 1116
            self.match(clipsparser.ROLE)
            self.state = 1117
            _la = self._input.LA(1)
            if not (_la == clipsparser.CONCRETE or _la == clipsparser.ABSTRACT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1118
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pattern_match_roleContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def PATTERNMATCH(self):
            return self.getToken(clipsparser.PATTERNMATCH, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def REACTIVE(self):
            return self.getToken(clipsparser.REACTIVE, 0)

        def NONREACTIVE(self):
            return self.getToken(clipsparser.NONREACTIVE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_pattern_match_role

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPattern_match_role"):
                listener.enterPattern_match_role(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPattern_match_role"):
                listener.exitPattern_match_role(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPattern_match_role"):
                return visitor.visitPattern_match_role(self)
            else:
                return visitor.visitChildren(self)

    def pattern_match_role(self):

        localctx = clipsparser.Pattern_match_roleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_pattern_match_role)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1120
            self.match(clipsparser.LeftParen)
            self.state = 1121
            self.match(clipsparser.PATTERNMATCH)
            self.state = 1122
            _la = self._input.LA(1)
            if not (_la == clipsparser.REACTIVE or _la == clipsparser.NONREACTIVE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1123
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SlotContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def SLOT(self):
            return self.getToken(clipsparser.SLOT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def facet(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.FacetContext)
            else:
                return self.getTypedRuleContext(clipsparser.FacetContext, i)

        def SINGLESLOT(self):
            return self.getToken(clipsparser.SINGLESLOT, 0)

        def MULTISLOT(self):
            return self.getToken(clipsparser.MULTISLOT, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_slot

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSlot"):
                listener.enterSlot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSlot"):
                listener.exitSlot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSlot"):
                return visitor.visitSlot(self)
            else:
                return visitor.visitChildren(self)

    def slot(self):

        localctx = clipsparser.SlotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_slot)
        self._la = 0  # Token type
        try:
            self.state = 1158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 114, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1125
                self.match(clipsparser.LeftParen)
                self.state = 1126
                self.match(clipsparser.SLOT)
                self.state = 1127
                self.symbol_expression()
                self.state = 1131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == clipsparser.LeftParen:
                    self.state = 1128
                    self.facet()
                    self.state = 1133
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1134
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1136
                self.match(clipsparser.LeftParen)
                self.state = 1137
                self.match(clipsparser.SINGLESLOT)
                self.state = 1138
                self.symbol_expression()
                self.state = 1142
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == clipsparser.LeftParen:
                    self.state = 1139
                    self.facet()
                    self.state = 1144
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1145
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1147
                self.match(clipsparser.LeftParen)
                self.state = 1148
                self.match(clipsparser.MULTISLOT)
                self.state = 1149
                self.symbol_expression()
                self.state = 1153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == clipsparser.LeftParen:
                    self.state = 1150
                    self.facet()
                    self.state = 1155
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1156
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FacetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def default_facet(self):
            return self.getTypedRuleContext(clipsparser.Default_facetContext, 0)

        def constaint_attr(self):
            return self.getTypedRuleContext(clipsparser.Constaint_attrContext, 0)

        def template_attr(self):
            return self.getTypedRuleContext(clipsparser.Template_attrContext, 0)

        def storage_facet(self):
            return self.getTypedRuleContext(clipsparser.Storage_facetContext, 0)

        def access_facet(self):
            return self.getTypedRuleContext(clipsparser.Access_facetContext, 0)

        def propagation_facet(self):
            return self.getTypedRuleContext(clipsparser.Propagation_facetContext, 0)

        def source_facet(self):
            return self.getTypedRuleContext(clipsparser.Source_facetContext, 0)

        def pattern_match_facet(self):
            return self.getTypedRuleContext(clipsparser.Pattern_match_facetContext, 0)

        def visibility_facet(self):
            return self.getTypedRuleContext(clipsparser.Visibility_facetContext, 0)

        def create_accessor_facet(self):
            return self.getTypedRuleContext(clipsparser.Create_accessor_facetContext, 0)

        def override_message_facet(self):
            return self.getTypedRuleContext(clipsparser.Override_message_facetContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFacet"):
                listener.enterFacet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFacet"):
                listener.exitFacet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFacet"):
                return visitor.visitFacet(self)
            else:
                return visitor.visitChildren(self)

    def facet(self):

        localctx = clipsparser.FacetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_facet)
        try:
            self.state = 1171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 115, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1160
                self.default_facet()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1161
                self.constaint_attr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1162
                self.template_attr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1163
                self.storage_facet()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1164
                self.access_facet()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1165
                self.propagation_facet()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1166
                self.source_facet()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1167
                self.pattern_match_facet()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1168
                self.visibility_facet()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1169
                self.create_accessor_facet()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1170
                self.override_message_facet()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Default_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFAULT(self):
            return self.getToken(clipsparser.DEFAULT, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def DERIVE(self):
            return self.getToken(clipsparser.DERIVE, 0)

        def NONE(self):
            return self.getToken(clipsparser.NONE, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def DEFAULTDYNAMIC(self):
            return self.getToken(clipsparser.DEFAULTDYNAMIC, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_default_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefault_facet"):
                listener.enterDefault_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefault_facet"):
                listener.exitDefault_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefault_facet"):
                return visitor.visitDefault_facet(self)
            else:
                return visitor.visitChildren(self)

    def default_facet(self):

        localctx = clipsparser.Default_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_default_facet)
        self._la = 0  # Token type
        try:
            self.state = 1195
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 119, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1173
                self.match(clipsparser.LeftParen)
                self.state = 1174
                self.match(clipsparser.DEFAULT)
                self.state = 1183
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [clipsparser.DERIVE]:
                    self.state = 1175
                    self.match(clipsparser.DERIVE)
                    pass
                elif token in [clipsparser.NONE]:
                    self.state = 1176
                    self.match(clipsparser.NONE)
                    pass
                elif token in [clipsparser.FLOAT, clipsparser.INTEGER, clipsparser.EQ, clipsparser.NEQ, clipsparser.MOD,
                               clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY,
                               clipsparser.LeftParen, clipsparser.RightParen, clipsparser.Less, clipsparser.LessEqual,
                               clipsparser.Greater, clipsparser.GreaterEqual, clipsparser.LessGreater, clipsparser.Plus,
                               clipsparser.Minus, clipsparser.Mul, clipsparser.Power, clipsparser.Div,
                               clipsparser.Int_div, clipsparser.Assign, clipsparser.Int_number,
                               clipsparser.Float_number, clipsparser.INSTANCE_name, clipsparser.ID,
                               clipsparser.STRING_literal, clipsparser.Global_var, clipsparser.Single_field_var,
                               clipsparser.Multi_field_var, clipsparser.COMMENT]:
                    self.state = 1180
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                            1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                    1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                            (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                            (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                            1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                    1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                    1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                    1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                    1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                    1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                    1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                    1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                    1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                                    1 << (clipsparser.Single_field_var - 110)) | (
                                    1 << (clipsparser.Multi_field_var - 110)) | (
                                    1 << (clipsparser.COMMENT - 110)))) != 0):
                        self.state = 1177
                        self.expression()
                        self.state = 1182
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1185
                self.match(clipsparser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1186
                self.match(clipsparser.LeftParen)
                self.state = 1187
                self.match(clipsparser.DEFAULTDYNAMIC)
                self.state = 1191
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                        1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                                1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                        (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                        (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                        1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                                1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                                1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                                1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                                1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                                1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                                1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                                1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                                1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                                1 << (clipsparser.Single_field_var - 110)) | (
                                1 << (clipsparser.Multi_field_var - 110)) | (1 << (clipsparser.COMMENT - 110)))) != 0):
                    self.state = 1188
                    self.expression()
                    self.state = 1193
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1194
                self.match(clipsparser.RightParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Storage_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def STORAGE(self):
            return self.getToken(clipsparser.STORAGE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def LOCAL(self):
            return self.getToken(clipsparser.LOCAL, 0)

        def SHARED(self):
            return self.getToken(clipsparser.SHARED, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_storage_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStorage_facet"):
                listener.enterStorage_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStorage_facet"):
                listener.exitStorage_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStorage_facet"):
                return visitor.visitStorage_facet(self)
            else:
                return visitor.visitChildren(self)

    def storage_facet(self):

        localctx = clipsparser.Storage_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_storage_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1197
            self.match(clipsparser.LeftParen)
            self.state = 1198
            self.match(clipsparser.STORAGE)
            self.state = 1199
            _la = self._input.LA(1)
            if not (_la == clipsparser.LOCAL or _la == clipsparser.SHARED):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1200
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Access_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def ACCESS(self):
            return self.getToken(clipsparser.ACCESS, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def READWRITE(self):
            return self.getToken(clipsparser.READWRITE, 0)

        def READONLY(self):
            return self.getToken(clipsparser.READONLY, 0)

        def INITIALIZEONLY(self):
            return self.getToken(clipsparser.INITIALIZEONLY, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_access_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAccess_facet"):
                listener.enterAccess_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAccess_facet"):
                listener.exitAccess_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAccess_facet"):
                return visitor.visitAccess_facet(self)
            else:
                return visitor.visitChildren(self)

    def access_facet(self):

        localctx = clipsparser.Access_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_access_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1202
            self.match(clipsparser.LeftParen)
            self.state = 1203
            self.match(clipsparser.ACCESS)
            self.state = 1204
            _la = self._input.LA(1)
            if not (((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & (
                    (1 << (clipsparser.READWRITE - 93)) | (1 << (clipsparser.READONLY - 93)) | (
                    1 << (clipsparser.INITIALIZEONLY - 93)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1205
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Propagation_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def PROPAGATION(self):
            return self.getToken(clipsparser.PROPAGATION, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def INHERIT(self):
            return self.getToken(clipsparser.INHERIT, 0)

        def NOINHERIT(self):
            return self.getToken(clipsparser.NOINHERIT, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_propagation_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPropagation_facet"):
                listener.enterPropagation_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPropagation_facet"):
                listener.exitPropagation_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPropagation_facet"):
                return visitor.visitPropagation_facet(self)
            else:
                return visitor.visitChildren(self)

    def propagation_facet(self):

        localctx = clipsparser.Propagation_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_propagation_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1207
            self.match(clipsparser.LeftParen)
            self.state = 1208
            self.match(clipsparser.PROPAGATION)
            self.state = 1209
            _la = self._input.LA(1)
            if not (_la == clipsparser.INHERIT or _la == clipsparser.NOINHERIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1210
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Source_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def SOURCE(self):
            return self.getToken(clipsparser.SOURCE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def EXCLUSIVE(self):
            return self.getToken(clipsparser.EXCLUSIVE, 0)

        def COMPOSITE(self):
            return self.getToken(clipsparser.COMPOSITE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_source_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSource_facet"):
                listener.enterSource_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSource_facet"):
                listener.exitSource_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSource_facet"):
                return visitor.visitSource_facet(self)
            else:
                return visitor.visitChildren(self)

    def source_facet(self):

        localctx = clipsparser.Source_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_source_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1212
            self.match(clipsparser.LeftParen)
            self.state = 1213
            self.match(clipsparser.SOURCE)
            self.state = 1214
            _la = self._input.LA(1)
            if not (_la == clipsparser.EXCLUSIVE or _la == clipsparser.COMPOSITE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1215
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pattern_match_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def PATTERNMATCH(self):
            return self.getToken(clipsparser.PATTERNMATCH, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def REACTIVE(self):
            return self.getToken(clipsparser.REACTIVE, 0)

        def NONREACTIVE(self):
            return self.getToken(clipsparser.NONREACTIVE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_pattern_match_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPattern_match_facet"):
                listener.enterPattern_match_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPattern_match_facet"):
                listener.exitPattern_match_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPattern_match_facet"):
                return visitor.visitPattern_match_facet(self)
            else:
                return visitor.visitChildren(self)

    def pattern_match_facet(self):

        localctx = clipsparser.Pattern_match_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_pattern_match_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1217
            self.match(clipsparser.LeftParen)
            self.state = 1218
            self.match(clipsparser.PATTERNMATCH)
            self.state = 1219
            _la = self._input.LA(1)
            if not (_la == clipsparser.REACTIVE or _la == clipsparser.NONREACTIVE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1220
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Visibility_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def VISIBILITY(self):
            return self.getToken(clipsparser.VISIBILITY, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def PRIVATE(self):
            return self.getToken(clipsparser.PRIVATE, 0)

        def PUBLIC(self):
            return self.getToken(clipsparser.PUBLIC, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_visibility_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVisibility_facet"):
                listener.enterVisibility_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVisibility_facet"):
                listener.exitVisibility_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVisibility_facet"):
                return visitor.visitVisibility_facet(self)
            else:
                return visitor.visitChildren(self)

    def visibility_facet(self):

        localctx = clipsparser.Visibility_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_visibility_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1222
            self.match(clipsparser.LeftParen)
            self.state = 1223
            self.match(clipsparser.VISIBILITY)
            self.state = 1224
            _la = self._input.LA(1)
            if not (_la == clipsparser.PRIVATE or _la == clipsparser.PUBLIC):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1225
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Create_accessor_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def CREATEACCESSOR(self):
            return self.getToken(clipsparser.CREATEACCESSOR, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def NONE(self):
            return self.getToken(clipsparser.NONE, 0)

        def READ(self):
            return self.getToken(clipsparser.READ, 0)

        def WRITE(self):
            return self.getToken(clipsparser.WRITE, 0)

        def READWRITE(self):
            return self.getToken(clipsparser.READWRITE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_create_accessor_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCreate_accessor_facet"):
                listener.enterCreate_accessor_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCreate_accessor_facet"):
                listener.exitCreate_accessor_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCreate_accessor_facet"):
                return visitor.visitCreate_accessor_facet(self)
            else:
                return visitor.visitChildren(self)

    def create_accessor_facet(self):

        localctx = clipsparser.Create_accessor_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_create_accessor_facet)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1227
            self.match(clipsparser.LeftParen)
            self.state = 1228
            self.match(clipsparser.CREATEACCESSOR)
            self.state = 1229
            _la = self._input.LA(1)
            if not (((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & (
                    (1 << (clipsparser.NONE - 73)) | (1 << (clipsparser.READWRITE - 73)) | (
                    1 << (clipsparser.READ - 73)) | (1 << (clipsparser.WRITE - 73)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1230
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Override_message_facetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def OVERRIDDEMESSAGE(self):
            return self.getToken(clipsparser.OVERRIDDEMESSAGE, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def CAPDEFAULT(self):
            return self.getToken(clipsparser.CAPDEFAULT, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_override_message_facet

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOverride_message_facet"):
                listener.enterOverride_message_facet(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOverride_message_facet"):
                listener.exitOverride_message_facet(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOverride_message_facet"):
                return visitor.visitOverride_message_facet(self)
            else:
                return visitor.visitChildren(self)

    def override_message_facet(self):

        localctx = clipsparser.Override_message_facetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_override_message_facet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            self.match(clipsparser.LeftParen)
            self.state = 1233
            self.match(clipsparser.OVERRIDDEMESSAGE)
            self.state = 1236
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.CAPDEFAULT]:
                self.state = 1234
                self.match(clipsparser.CAPDEFAULT)
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY, clipsparser.ID]:
                self.state = 1235
                self.symbol_expression()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1238
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Handler_documentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def MESSAGEHANDLER(self):
            return self.getToken(clipsparser.MESSAGEHANDLER, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def handler_type(self):
            return self.getTypedRuleContext(clipsparser.Handler_typeContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_handler_document

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHandler_document"):
                listener.enterHandler_document(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHandler_document"):
                listener.exitHandler_document(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitHandler_document"):
                return visitor.visitHandler_document(self)
            else:
                return visitor.visitChildren(self)

    def handler_document(self):

        localctx = clipsparser.Handler_documentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_handler_document)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1240
            self.match(clipsparser.LeftParen)
            self.state = 1241
            self.match(clipsparser.MESSAGEHANDLER)
            self.state = 1242
            self.symbol_expression()
            self.state = 1244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.AROUND - 110)) | (
                    1 << (clipsparser.BEFORE - 110)) | (1 << (clipsparser.AFTER - 110)))) != 0):
                self.state = 1243
                self.handler_type()

            self.state = 1246
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Handler_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIMARY(self):
            return self.getToken(clipsparser.PRIMARY, 0)

        def AROUND(self):
            return self.getToken(clipsparser.AROUND, 0)

        def BEFORE(self):
            return self.getToken(clipsparser.BEFORE, 0)

        def AFTER(self):
            return self.getToken(clipsparser.AFTER, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_handler_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHandler_type"):
                listener.enterHandler_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHandler_type"):
                listener.exitHandler_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitHandler_type"):
                return visitor.visitHandler_type(self)
            else:
                return visitor.visitChildren(self)

    def handler_type(self):

        localctx = clipsparser.Handler_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_handler_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1248
            _la = self._input.LA(1)
            if not (((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.AROUND - 110)) | (
                    1 << (clipsparser.BEFORE - 110)) | (1 << (clipsparser.AFTER - 110)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefgenericContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFGENERIC(self):
            return self.getToken(clipsparser.DEFGENERIC, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_defgeneric

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefgeneric"):
                listener.enterDefgeneric(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefgeneric"):
                listener.exitDefgeneric(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefgeneric"):
                return visitor.visitDefgeneric(self)
            else:
                return visitor.visitChildren(self)

    def defgeneric(self):

        localctx = clipsparser.DefgenericContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_defgeneric)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1250
            self.match(clipsparser.LeftParen)
            self.state = 1251
            self.match(clipsparser.DEFGENERIC)
            self.state = 1252
            self.symbol_expression()
            self.state = 1254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 1253
                self.string_expression()

            self.state = 1256
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefinstancesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def DEFINSTANCES(self):
            return self.getToken(clipsparser.DEFINSTANCES, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def ACTIVE(self):
            return self.getToken(clipsparser.ACTIVE, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def instance_template(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Instance_templateContext)
            else:
                return self.getTypedRuleContext(clipsparser.Instance_templateContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_definstances

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefinstances"):
                listener.enterDefinstances(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefinstances"):
                listener.exitDefinstances(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefinstances"):
                return visitor.visitDefinstances(self)
            else:
                return visitor.visitChildren(self)

    def definstances(self):

        localctx = clipsparser.DefinstancesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_definstances)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1258
            self.match(clipsparser.LeftParen)
            self.state = 1259
            self.match(clipsparser.DEFINSTANCES)
            self.state = 1260
            self.symbol_expression()
            self.state = 1262
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.ACTIVE:
                self.state = 1261
                self.match(clipsparser.ACTIVE)

            self.state = 1265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == clipsparser.STRING_literal:
                self.state = 1264
                self.string_expression()

            self.state = 1270
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 1267
                self.instance_template()
                self.state = 1272
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1273
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instance_templateContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def instance_definition(self):
            return self.getTypedRuleContext(clipsparser.Instance_definitionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_instance_template

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstance_template"):
                listener.enterInstance_template(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstance_template"):
                listener.exitInstance_template(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstance_template"):
                return visitor.visitInstance_template(self)
            else:
                return visitor.visitChildren(self)

    def instance_template(self):

        localctx = clipsparser.Instance_templateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_instance_template)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1275
            self.match(clipsparser.LeftParen)
            self.state = 1276
            self.instance_definition()
            self.state = 1277
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instance_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OF(self):
            return self.getToken(clipsparser.OF, 0)

        def class_name(self):
            return self.getTypedRuleContext(clipsparser.Class_nameContext, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def slot_override(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Slot_overrideContext)
            else:
                return self.getTypedRuleContext(clipsparser.Slot_overrideContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_instance_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstance_definition"):
                listener.enterInstance_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstance_definition"):
                listener.exitInstance_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstance_definition"):
                return visitor.visitInstance_definition(self)
            else:
                return visitor.visitChildren(self)

    def instance_definition(self):

        localctx = clipsparser.Instance_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_instance_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                    1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID:
                self.state = 1279
                self.symbol_expression()

            self.state = 1282
            self.match(clipsparser.OF)
            self.state = 1283
            self.class_name()
            self.state = 1287
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == clipsparser.LeftParen:
                self.state = 1284
                self.slot_override()
                self.state = 1289
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Slot_overrideContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ExpressionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ExpressionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_slot_override

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSlot_override"):
                listener.enterSlot_override(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSlot_override"):
                listener.exitSlot_override(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSlot_override"):
                return visitor.visitSlot_override(self)
            else:
                return visitor.visitChildren(self)

    def slot_override(self):

        localctx = clipsparser.Slot_overrideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_slot_override)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1290
            self.match(clipsparser.LeftParen)
            self.state = 1291
            self.symbol_expression()
            self.state = 1295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 1292
                self.expression()
                self.state = 1297
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1298
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InstancesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_instancep(self):
            return self.getTypedRuleContext(clipsparser.Any_instancepContext, 0)

        def find_instance(self):
            return self.getTypedRuleContext(clipsparser.Find_instanceContext, 0)

        def do_for_instance(self):
            return self.getTypedRuleContext(clipsparser.Do_for_instanceContext, 0)

        def make_instance(self):
            return self.getTypedRuleContext(clipsparser.Make_instanceContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_instances

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstances"):
                listener.enterInstances(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstances"):
                listener.exitInstances(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstances"):
                return visitor.visitInstances(self)
            else:
                return visitor.visitChildren(self)

    def instances(self):

        localctx = clipsparser.InstancesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_instances)
        try:
            self.state = 1304
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 129, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1300
                self.any_instancep()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1301
                self.find_instance()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1302
                self.do_for_instance()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1303
                self.make_instance()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Any_instancepContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def ANYINSTANCEP(self):
            return self.getToken(clipsparser.ANYINSTANCEP, 0)

        def instance_set_template(self):
            return self.getTypedRuleContext(clipsparser.Instance_set_templateContext, 0)

        def query(self):
            return self.getTypedRuleContext(clipsparser.QueryContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_any_instancep

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAny_instancep"):
                listener.enterAny_instancep(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAny_instancep"):
                listener.exitAny_instancep(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAny_instancep"):
                return visitor.visitAny_instancep(self)
            else:
                return visitor.visitChildren(self)

    def any_instancep(self):

        localctx = clipsparser.Any_instancepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_any_instancep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1306
            self.match(clipsparser.LeftParen)
            self.state = 1307
            self.match(clipsparser.ANYINSTANCEP)
            self.state = 1308
            self.instance_set_template()
            self.state = 1309
            self.query()
            self.state = 1310
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Find_instanceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def instance_set_template(self):
            return self.getTypedRuleContext(clipsparser.Instance_set_templateContext, 0)

        def query(self):
            return self.getTypedRuleContext(clipsparser.QueryContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def FINDINSTANCE(self):
            return self.getToken(clipsparser.FINDINSTANCE, 0)

        def FINDALLINSTANCES(self):
            return self.getToken(clipsparser.FINDALLINSTANCES, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_find_instance

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFind_instance"):
                listener.enterFind_instance(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFind_instance"):
                listener.exitFind_instance(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFind_instance"):
                return visitor.visitFind_instance(self)
            else:
                return visitor.visitChildren(self)

    def find_instance(self):

        localctx = clipsparser.Find_instanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_find_instance)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1312
            self.match(clipsparser.LeftParen)
            self.state = 1313
            _la = self._input.LA(1)
            if not (_la == clipsparser.FINDINSTANCE or _la == clipsparser.FINDALLINSTANCES):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1314
            self.instance_set_template()
            self.state = 1315
            self.query()
            self.state = 1316
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Do_for_instanceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def instance_set_template(self):
            return self.getTypedRuleContext(clipsparser.Instance_set_templateContext, 0)

        def query(self):
            return self.getTypedRuleContext(clipsparser.QueryContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def DOFORINSTANCE(self):
            return self.getToken(clipsparser.DOFORINSTANCE, 0)

        def DOFORALLINSTANCES(self):
            return self.getToken(clipsparser.DOFORALLINSTANCES, 0)

        def DELAYEDINSTANCES(self):
            return self.getToken(clipsparser.DELAYEDINSTANCES, 0)

        def action(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.ActionContext)
            else:
                return self.getTypedRuleContext(clipsparser.ActionContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_do_for_instance

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDo_for_instance"):
                listener.enterDo_for_instance(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDo_for_instance"):
                listener.exitDo_for_instance(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDo_for_instance"):
                return visitor.visitDo_for_instance(self)
            else:
                return visitor.visitChildren(self)

    def do_for_instance(self):

        localctx = clipsparser.Do_for_instanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_do_for_instance)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1318
            self.match(clipsparser.LeftParen)
            self.state = 1319
            _la = self._input.LA(1)
            if not (((((_la - 118)) & ~0x3f) == 0 and ((1 << (_la - 118)) & (
                    (1 << (clipsparser.DOFORINSTANCE - 118)) | (1 << (clipsparser.DOFORALLINSTANCES - 118)) | (
                    1 << (clipsparser.DELAYEDINSTANCES - 118)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1320
            self.instance_set_template()
            self.state = 1321
            self.query()
            self.state = 1325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << clipsparser.FLOAT) | (1 << clipsparser.INTEGER) | (1 << clipsparser.EQ) | (
                    1 << clipsparser.NEQ) | (1 << clipsparser.MOD) | (1 << clipsparser.TRUE) | (
                            1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0) or (
                    (((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & (
                    (1 << (clipsparser.PRIMARY - 110)) | (1 << (clipsparser.LeftParen - 110)) | (
                    1 << (clipsparser.Less - 110)) | (1 << (clipsparser.LessEqual - 110)) | (
                            1 << (clipsparser.Greater - 110)) | (1 << (clipsparser.GreaterEqual - 110)) | (
                            1 << (clipsparser.LessGreater - 110)) | (1 << (clipsparser.Plus - 110)) | (
                            1 << (clipsparser.Minus - 110)) | (1 << (clipsparser.Mul - 110)) | (
                            1 << (clipsparser.Power - 110)) | (1 << (clipsparser.Div - 110)) | (
                            1 << (clipsparser.Int_div - 110)) | (1 << (clipsparser.Assign - 110)) | (
                            1 << (clipsparser.Int_number - 110)) | (1 << (clipsparser.Float_number - 110)) | (
                            1 << (clipsparser.INSTANCE_name - 110)) | (1 << (clipsparser.ID - 110)) | (
                            1 << (clipsparser.STRING_literal - 110)) | (1 << (clipsparser.Global_var - 110)) | (
                            1 << (clipsparser.Single_field_var - 110)) | (1 << (clipsparser.Multi_field_var - 110)) | (
                            1 << (clipsparser.COMMENT - 110)))) != 0):
                self.state = 1322
                self.action()
                self.state = 1327
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1328
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(clipsparser.ExpressionContext, 0)

        def TRUE(self):
            return self.getToken(clipsparser.TRUE, 0)

        def FALSE(self):
            return self.getToken(clipsparser.FALSE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery"):
                listener.enterQuery(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery"):
                listener.exitQuery(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery"):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)

    def query(self):

        localctx = clipsparser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_query)
        try:
            self.state = 1333
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 131, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1330
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1331
                self.match(clipsparser.TRUE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1332
                self.match(clipsparser.FALSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instance_set_templateContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def instance_set_member_template(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Instance_set_member_templateContext)
            else:
                return self.getTypedRuleContext(clipsparser.Instance_set_member_templateContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_instance_set_template

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstance_set_template"):
                listener.enterInstance_set_template(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstance_set_template"):
                listener.exitInstance_set_template(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstance_set_template"):
                return visitor.visitInstance_set_template(self)
            else:
                return visitor.visitChildren(self)

    def instance_set_template(self):

        localctx = clipsparser.Instance_set_templateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_instance_set_template)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1335
            self.match(clipsparser.LeftParen)
            self.state = 1337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1336
                self.instance_set_member_template()
                self.state = 1339
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == clipsparser.LeftParen):
                    break

            self.state = 1341
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instance_set_member_templateContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def Single_field_var(self):
            return self.getToken(clipsparser.Single_field_var, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def class_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(clipsparser.Class_nameContext)
            else:
                return self.getTypedRuleContext(clipsparser.Class_nameContext, i)

        def getRuleIndex(self):
            return clipsparser.RULE_instance_set_member_template

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstance_set_member_template"):
                listener.enterInstance_set_member_template(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstance_set_member_template"):
                listener.exitInstance_set_member_template(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstance_set_member_template"):
                return visitor.visitInstance_set_member_template(self)
            else:
                return visitor.visitChildren(self)

    def instance_set_member_template(self):

        localctx = clipsparser.Instance_set_member_templateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_instance_set_member_template)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1343
            self.match(clipsparser.LeftParen)
            self.state = 1344
            self.match(clipsparser.Single_field_var)
            self.state = 1346
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1345
                self.class_name()
                self.state = 1348
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (
                        1 << clipsparser.NULL))) != 0) or _la == clipsparser.PRIMARY or _la == clipsparser.ID):
                    break

            self.state = 1350
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Make_instanceContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(clipsparser.LeftParen, 0)

        def instance_definition(self):
            return self.getTypedRuleContext(clipsparser.Instance_definitionContext, 0)

        def RightParen(self):
            return self.getToken(clipsparser.RightParen, 0)

        def MAKEINSTANCE(self):
            return self.getToken(clipsparser.MAKEINSTANCE, 0)

        def ACTIVEMAKEINSTANCE(self):
            return self.getToken(clipsparser.ACTIVEMAKEINSTANCE, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_make_instance

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMake_instance"):
                listener.enterMake_instance(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMake_instance"):
                listener.exitMake_instance(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMake_instance"):
                return visitor.visitMake_instance(self)
            else:
                return visitor.visitChildren(self)

    def make_instance(self):

        localctx = clipsparser.Make_instanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_make_instance)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1352
            self.match(clipsparser.LeftParen)
            self.state = 1353
            _la = self._input.LA(1)
            if not (_la == clipsparser.MAKEINSTANCE or _la == clipsparser.ACTIVEMAKEINSTANCE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1354
            self.instance_definition()
            self.state = 1355
            self.match(clipsparser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Integer_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Int_number(self):
            return self.getToken(clipsparser.Int_number, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_integer_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInteger_expression"):
                listener.enterInteger_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInteger_expression"):
                listener.exitInteger_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInteger_expression"):
                return visitor.visitInteger_expression(self)
            else:
                return visitor.visitChildren(self)

    def integer_expression(self):

        localctx = clipsparser.Integer_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_integer_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1357
            self.match(clipsparser.Int_number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Float_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Float_number(self):
            return self.getToken(clipsparser.Float_number, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_float_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloat_expression"):
                listener.enterFloat_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloat_expression"):
                listener.exitFloat_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFloat_expression"):
                return visitor.visitFloat_expression(self)
            else:
                return visitor.visitChildren(self)

    def float_expression(self):

        localctx = clipsparser.Float_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_float_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1359
            self.match(clipsparser.Float_number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Symbol_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolen_symbol(self):
            return self.getTypedRuleContext(clipsparser.Boolen_symbolContext, 0)

        def PRIMARY(self):
            return self.getToken(clipsparser.PRIMARY, 0)

        def ID(self):
            return self.getToken(clipsparser.ID, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_symbol_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSymbol_expression"):
                listener.enterSymbol_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSymbol_expression"):
                listener.exitSymbol_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSymbol_expression"):
                return visitor.visitSymbol_expression(self)
            else:
                return visitor.visitChildren(self)

    def symbol_expression(self):

        localctx = clipsparser.Symbol_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_symbol_expression)
        try:
            self.state = 1364
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1361
                self.boolen_symbol()
                pass
            elif token in [clipsparser.PRIMARY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1362
                self.match(clipsparser.PRIMARY)
                pass
            elif token in [clipsparser.ID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1363
                self.match(clipsparser.ID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_literal(self):
            return self.getToken(clipsparser.STRING_literal, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_string_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterString_expression"):
                listener.enterString_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitString_expression"):
                listener.exitString_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitString_expression"):
                return visitor.visitString_expression(self)
            else:
                return visitor.visitChildren(self)

    def string_expression(self):

        localctx = clipsparser.String_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_string_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1366
            self.match(clipsparser.STRING_literal)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instancename_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSTANCE_name(self):
            return self.getToken(clipsparser.INSTANCE_name, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_instancename_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstancename_expression"):
                listener.enterInstancename_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstancename_expression"):
                listener.exitInstancename_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstancename_expression"):
                return visitor.visitInstancename_expression(self)
            else:
                return visitor.visitChildren(self)

    def instancename_expression(self):

        localctx = clipsparser.Instancename_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_instancename_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1368
            self.match(clipsparser.INSTANCE_name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer_expression(self):
            return self.getTypedRuleContext(clipsparser.Integer_expressionContext, 0)

        def float_expression(self):
            return self.getTypedRuleContext(clipsparser.Float_expressionContext, 0)

        def symbol_expression(self):
            return self.getTypedRuleContext(clipsparser.Symbol_expressionContext, 0)

        def string_expression(self):
            return self.getTypedRuleContext(clipsparser.String_expressionContext, 0)

        def instancename_expression(self):
            return self.getTypedRuleContext(clipsparser.Instancename_expressionContext, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_constant_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant_expression"):
                listener.enterConstant_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant_expression"):
                listener.exitConstant_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant_expression"):
                return visitor.visitConstant_expression(self)
            else:
                return visitor.visitChildren(self)

    def constant_expression(self):

        localctx = clipsparser.Constant_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_constant_expression)
        try:
            self.state = 1375
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [clipsparser.Int_number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1370
                self.integer_expression()
                pass
            elif token in [clipsparser.Float_number]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1371
                self.float_expression()
                pass
            elif token in [clipsparser.TRUE, clipsparser.FALSE, clipsparser.NULL, clipsparser.PRIMARY, clipsparser.ID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1372
                self.symbol_expression()
                pass
            elif token in [clipsparser.STRING_literal]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1373
                self.string_expression()
                pass
            elif token in [clipsparser.INSTANCE_name]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1374
                self.instancename_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Boolen_symbolContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(clipsparser.TRUE, 0)

        def FALSE(self):
            return self.getToken(clipsparser.FALSE, 0)

        def NULL(self):
            return self.getToken(clipsparser.NULL, 0)

        def getRuleIndex(self):
            return clipsparser.RULE_boolen_symbol

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBoolen_symbol"):
                listener.enterBoolen_symbol(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBoolen_symbol"):
                listener.exitBoolen_symbol(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBoolen_symbol"):
                return visitor.visitBoolen_symbol(self)
            else:
                return visitor.visitChildren(self)

    def boolen_symbol(self):

        localctx = clipsparser.Boolen_symbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_boolen_symbol)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1377
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and (
                    (1 << _la) & ((1 << clipsparser.TRUE) | (1 << clipsparser.FALSE) | (1 << clipsparser.NULL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
